[{"title":".NET日志(1)：概论","url":"/2025/12/12/dotnet-logging-1-introduction/","content":"日志类别 Log Category日志类别只是一种逻辑方式，用于将不同的日志条目归类到某种统一的分组下。例如，如果你正在运行一个API，微软会将其自身的所有日志归类在Microsoft.Asp.Core这个类别或分组下，你也可以控制自己的日志类别。\n\nILogger&lt;类&gt;：通常是当前类，如ILogger&lt;Program&gt;\nLogInformation方法：打印info级别的日志\n\ninfo: Program[0]      Hello World!\n\n\nProgram：日志类别\n[0]：事件ID\n\n日志级别 Log Level日记级别代表日志的严重程度：Trace&lt;…&lt;Critical，详见LogLevel枚举。\n\nTrace包含最详细的记录，甚至可以是敏感记录，不能用于生产环境，默认禁用。\nDebug用于在开发过程中调试程序，一般不用于生产环境。\nInformation一般是默认的级别，用于跟踪应用程序的一般流程，可以存储并具有长期价值。\nWarning用于突出异常或意外情况，但并不意味着应用程序崩溃、停止或存在根本性错误。\nError表示确实崩溃了，应用程序遇到了无法处理的异常。\nCritical表示彻底崩溃，应用程序遇到了不可挽回的致命错误。\n\n日志提供程序 Log Provider日志提供程序是日志的输出目标。目标可以是任何东西，它可以是控制台、事件日志、数据库、第三方服务……任何地方。\n","categories":["编程","C#技术栈",".NET日志"]},{"title":".NET日志(2)：Microsoft.Extensions.Logging包","url":"/2025/12/12/dotnet-logging-2-microsoft-extensions-logging/","content":"ILogger并不是一个BCL（Basic Class Library，基础类库）接口，而是来自于Microsoft.Extensions.Logging包。如果你是一个类库作者，你可以引用Microsoft.Extensions.Logging.Abstraction抽象依赖，因为开发类库通常用不上这些具体实现。\n\nLoggerFactory日志记录器工厂：\nCreate静态方法：创建一个工厂\nCreateLogger&lt;&gt;方法：创建一个日志记录器\n\n\n\nLoggerFactory.Create(builder =&gt; &#123; builder.AddConsole(); &#125;);ILogger logger = loggerFactory.CreateLogger&lt;Program&gt;();\n\n\nILogger日志记录器：\nLog方法：logLevel, eventId（事件ID）, message\nLogInformation等扩展方法：封装Log方法，常用\n\n\n\n结构化日志记录&#x2F;语义化日志记录不要使用字符串拼接、模板字符串或格式字符串来传递日志消息，这会导致具体的参数值“烘焙”到日志消息中，从而丢失OriginalFormat（原始格式）。我们希望捕获上下文、作用域、细节和信息，而这正是消息模板字符串和“结构化日志记录”所解决的问题。\n\nMicrosoft.Extensions.Logging.Console：\nILoggingBuilder.AddJsonConsole方法：控制台输出结构化的JSON日志\n\n\n\nusing var loggerFactory = LoggerFactory.Create(builder =&gt; &#123; builder.AddJsonConsole(); &#125;);var logger = loggerFactory.CreateLogger&lt;Program&gt;();logger.LogInformation(&quot;Hello World! It is &#123;At&#125;.&quot;, DateTime.UtcNow);//&#123;&quot;EventId&quot;:0,&quot;LogLevel&quot;:&quot;Information&quot;,&quot;Category&quot;:&quot;Program&quot;,&quot;Message&quot;:&quot;Hello World! It is 12/12/2025 02:17:20.&quot;,&quot;State&quot;:&#123;&quot;Message&quot;:&quot;Hello World! It is 12/12/2025 02:17:20.&quot;,&quot;At&quot;:&quot;12/12/2025 02:17:20&quot;,&quot;&#123;OriginalFormat&#125;&quot;:&quot;Hello World! It is &#123;At&#125;.&quot;&#125;&#125;\n\n日志类别约定日志类别通常约定为注入或使用ILogger&lt;类&gt;的类名。从.NET 6开始，任何自动的依赖注入服务都不会自动注入非泛型的ILogger。\n日志级别约定默认情况下，无论是JSON控制台还是普通控制台，它们的最低日志级别都是Information，这意味着它们会完全忽略Debug或Trace级别的日志。\n\n要设置最低日志级别，使用ILoggingBuilder.SetMinimumLevel方法：\n\nbuilder.SetMinimumLevel(LogLevel.Trace);\n\n在现代应用程序中，尤其是ASP.NET Core中，这类配置通常会集中放在相应的appsettings.json文件中，或你正在使用的其他配置提供程序中。这会自动配置最低日志级别，无需在代码中手动配置。\n日志事件ID事件ID用于给一种类型的事件打标签，一个ID代表一种事件。\nlogger.LogInformation(233, &quot;ID为233的事件发生了。&quot;);\n\n非常常见的一种做法是，人们会创建一个事件类，用于集中放置事件ID：\npublic class LogEvents &#123;\tpublic const int SomeEvent = 233;&#125;\n\n现代结构化日志框架有很多为日志打标签的替代方案，然而事件ID仍是一个非常强大的工具。\n主机应用 Host主机通常需要长时间运行，并为客户提供服务，适用于后台工作进程，常见于Web框架。要在非主机控制台应用中使用主机，引入Microsoft.Extensions.Hosting包。\nLogging包提供主机IHost的ConfigureLogging扩展方法，接收ILoggingBuilder，从而为主机配置日志服务。\n自定义ILogger日志记录器与Provider日志提供程序配置ILogger日志记录器：\nbuilder.AddJsonConsole().SetMinimumLevel(LogLevel.Trace);\n\n\nClearProviders方法：清除之前添加的提供程序，从而接着可以换成你想要的\n\n配置Provider日志提供程序：\nbuilder.AddJsonConsole(options =&gt; &#123;      options.IncludeScopes = false;  //禁用作用域    options.TimestampFormat = &quot;[yyyy-MM-dd HH:mm:ss] &quot;;      options.JsonWriterOptions = new JsonWriterOptions &#123;  \t    Indented = true  //以缩进形式输出JSON\t&#125;;&#125;);/* &#123;    &quot;Timestamp&quot;: &quot;[2025-12-12 11:15:07] &quot;,    &quot;EventId&quot;: 233,    &quot;LogLevel&quot;: &quot;Information&quot;,    &quot;Category&quot;: &quot;Program&quot;,    &quot;Message&quot;: &quot;Hello World! It is 12/12/2025 03:15:07.&quot;,    &quot;State&quot;: &#123;        &quot;Message&quot;: &quot;Hello World! It is 12/12/2025 03:15:07.&quot;,        &quot;At&quot;: &quot;12/12/2025 03:15:07&quot;,        &quot;&#123;OriginalFormat&#125;&quot;: &quot;Hello World! It is &#123;At&#125;.&quot;    &#125;&#125; */\n\n在appsettings.json中配置日志服务你不应该每次为了调整日志配置，都必须修改代码中的日志逻辑，并重新部署应用程序，而是应该将这些配置放在外部的配置文件中。\nappsettings.json是大多数类型的应用程序项目模板中的标准配置文件，包括针对特定环境的版本appsettings.Development.json和不区分环境的通用版本appsettings.json。\n\n日志记录异常你可以捕获异常，并把它放到Log方法的第一个参数，来记录异常日志。\ntry &#123;\tthrow new Exception(&quot;Something went wrong&quot;);&#125; catch (Exception ex) &#123;\tlogger.LogWarning(ex, &quot;Failure during birthday of &#123;Name&#125; who is &#123;Age&#125;&quot;, name, age);&#125;\n\n日志过滤器通过LoggingBuilder.AddFilter方法设置日志过滤器，它接收返回布尔值的委托。这个委托可以不传参数，也可以传入提供程序 provider、类别 category 和级别 logLevel。之前设置最低日志级别时，背后就是用到了日志过滤器。\n\nAddFilter&lt;SomeProvider&gt;(类别, 级别)可以针对SomeProvider过滤。\n\n不过，这种方式更可能在你为他人开发类库时派上用场，而不是在构建微服务这类服务时，因为大多数配置实际上都会放在你的 appsettings.json 中。但知道你拥有灵活性，以备不时之需，总是好的。\n日志提供程序 LoggerProvider控制台是临时日志提供程序，一旦停止运行，它和它的日志缓存就不存在了，它们不是持久化的。相反，文件系统就是能够持久存储日志的提供程序。\n\nASP.NET Core 显式或隐式内置了 Microsoft.Extensions.Logging 的 Console、Debug、EventLog、EventSource 和 TraceSource 提供程序。\nMicrosoft Azure 的云端日志提供程序：ApplicaitonInsights。\n\n在控制台中配置 ApplicaitonInsights 提供程序：\n\n引入NuGet包：\nMicrosoft.ApplicaitonInsights\nMicrosoft.Extensions.DependencyInjection\nMicrosoft.Extensions.Options.ConfigurationExtensions\nMicrosoft.Extensions.Logging\nMicrosoft.Extensions.Logging.ApplicaitonInsights\n\n\n\nusing var channel = new InMemoryChannel();try&#123;\tIServiceCollection services = new ServiceCollection();\tservices.Configure&lt;TelemetryConfiguration&gt;(x =&gt; x.TelemetryChannel = channel);\tservices.AddLogging(x =&gt;\t&#123;\t\tx.AddApplicationInsights(\t\t\tconfigureTelemetryConfiguration: teleConfig =&gt;\t\t\t\tteleConfig.ConnectionString = &quot;your_connection_string&quot;,\t\t\tconfigureApplicationInsightsLoggerOptions: _ =&gt; &#123;&#125;\t\t);\t&#125;);\tvar serviceProvider = services.BuildServiceProvider();\tvar logging = serviceProvider.GetRquiredService&lt;ILogger&lt;Program&gt;&gt;();\tlogging.LogInformation(&quot;Hello from console!&quot;);&#125;finally&#123;\tawait channel.FlushAsync(default);\tawait Task.Delay(1000);&#125;\n\n根据不同的运行环境配置不同的日志提供程序在生产环境中，你不希望日志泛滥。你需要对日志行为非常精准地控制，像在生产环境中使用控制台日志记录，可能会拖垮应用程序的性能。在 ASP.NET Core 中，builder.Environment.IsDevelopment方法可以返回当前是否在开发环境。\n\n这里要获取ILoggingBuilder，使用builder.Logging属性。\n与开发环境（Development）平行的是生产环境（Production）。\n\n自定义日志提供程序要自定义日志提供程序，实现ILogger和ILoggerProvider接口，并在你的LoggerProvider的CreateLogger方法中返回你的Logger。\n\nILogger接口：\nTState泛型：包含实际日志消息的参数的泛型\nBeginScope方法：开启作用域\nIsEnabled方法：返回是否启用\nLog方法：如果启用，记录日志\n\n\n\n日志消息模板字符串\n{Total:C}：当前文化的货币格式\n{Date:F}：当前文化的日期完整格式\n{Date:u}：universal sortable date，通用可排序日期格式\n\n要实现复杂类型数据的格式化和结构化，你不得不使用JsonSerializer。此时，如果你又要使用JsonConsole，会出现JSON嵌套在JSON中的情况，你必须谨慎处理这里的序列化过程。\n日志作用域 Log Scope在代码中，存在一段从开始到结束都需要处理特定上下文的区域，这个上下文可能是某种特定的支付、特定的订单、购物车，或者任何在你的业务领域中有意义的内容。尽管一些日志是独立的，但它们所关联的大量数据都与特定的上下文相关。\n\nJsonConsole的Options：\nIncludeScopes属性：是否包含作用域；为true时，结果中将出现Scopes属性，它是一个数组，包含所有上下文数据\n\n\n\nusing (logging.BeginScope(&quot;&#123;PaymentId&#125;&quot;, paymentId))using (logging.BeginScope(&quot;&#123;TotalAmount:C&#125;&quot;, amount))&#123;\ttry\t&#123;\t\tlogger.LogInformation(&quot;New payment processing&quot;);\t\t//processing new payment\t&#125;\tfinally\t&#123;\t\tlogger.LogInformation(&quot;Payment processing completed&quot;);\t&#125;&#125;\n\n\nPaymentId和TotalAmount将作为上下文数据由作用域内的所有日志共享，它们将包含在这些日志的Scopes数组中。\n\n检查日志是否启用虽然日志提供程序通常都会在Log方法的开头检查是否启用，但是为以防万一，你应该在自己的代码中也加入IsEnabled的判断，以确保没有性能问题。\n日志记录操作耗时下面是利用Stopwatch类和日志上下文机制记录操作耗时的方法。\nStopwatch类是.NET中测量时间最精确的方案：\n\nGetTimestamp静态方法：获取当前时间戳\nGetElapsedTime静态方法：获取传入时间戳到现在的时间间隔\n\n可以用Stopwatch类结合作用域机制，获取并记录操作耗时。\n创建TimedOperation类，聚合_logger、_logLevel、_eventId、_message 和 _args，实现IDisposable接口：\n\n在构造方法中获取当前时间戳\n在Dispose方法获取时间间隔，并调用_logger.Log方法记录耗时日志\n\n创建TimedOperationExtensions类，扩展以支持ILogger接口：\n\nBeginTimedOperation方法：创建并返回TimedOperation对象，用作上下文数据\n创建一个不传入LogLevel的BeginTimedOperation方法重载，并默认使用Information级别\n\nusing (logger.BeginTimedOperation(&quot;Handling new payment&quot;))&#123;\tlogger.LogInformation(&quot;New payment processing&quot;);\t//processing new payment\tawait Task.Delay(10);&#125;\n\n运行时动态修改最低日志级别在你的应用程序中，只要支持在运行时热重载或动态重载appsettings.json配置文件，就可以实现运行时动态修改最低日志级别这一功能。而这就是配置提供程序要做的事情了。\n","categories":["编程","C#技术栈",".NET日志"]},{"title":"C#常见集合接口","url":"/2025/08/26/cs-common-collections-api/","content":"下面只列出泛型接口，没有泛型的版本的接口处理数据的逻辑差不多，只是需要装拆箱。\n\nIEnumerable&lt;TItem&gt;：可迭代、可枚举类型\nGetEnumerator 方法：获取迭代器&#x2F;枚举器\n\n\nIEnumerator&lt;TItem&gt;：枚举器，初始不指向任何元素，要调用一次MoveNext方法启动枚举器\nCurrent属性：当前元素，只get\nMoveNext方法：启动枚举器，让它指向首个元素（初始）；移动枚举器，让它指向下一个元素（非初始）\nReset 方法：重置枚举器到初始状态\n\n\nICollection&lt;TItem&gt;：集合\nAdd 方法\nRemove 方法\n\n\nIList&lt;TItem&gt;：列表\n[int index] 索引器：指定索引的元素，get和set\nIsFixedSize属性：有无固定大小，只get\nIsReadOnly属性：是否只读，只get\nCount属性：元素个数，只get\nIsSynchronized属性\nSyncRoot属性\nAdd方法\nClear方法\nContains方法\nCopyTo方法\nGetEnumerator方法\nIndexOf方法\nInsert方法\nRemove方法\nRemoveAt方法\n\n\nIDictionary&lt;TKey, TValue&gt;：字典\n\n来源：刘铁猛《C#语言入门详解》全集\n","categories":["编程","C#技术栈","C#基础"]},{"title":".NET日志(3)：Serilog","url":"/2025/12/13/dotnet-logging-3-serilog/","content":"无论是作用域、IsEnabled、格式化或消息模板的概念，还是结构化日志记录，Serilog都是这些功能的开创者和标准化者。\n\n对消息模板、结构化日志、参数解析等都有极佳的支持。\n庞大的Sinks家族：Serilog的Sinks就相当于Logging中的Provider，而Serilog的Sinks可能有几十个甚至上百个。\n\n创建Serilog日志记录器\n引入Serilog包\n\nvar logger = new LoggerConfiguration().CreateLogger();\n\n配置Serilog日志接收器 Sinks\n想要什么接收器，就引入什么Serilog.Sinks.SomeSink包\nLoggerConfiguration.WirteTo属性：Sinks扩展该属性以配置它自己，通常是SomeSinks扩展方法\n\nvar logger = new LoggerConfiguration()      .WriteTo.Console(theme: AnsiConsoleTheme.Code)      .CreateLogger();\n\n\nSerilog.Sinks.Console包：\nConsole扩展方法：\ntheme参数：自定义控制台日志的配色方案\n\n\n\n\nSerilog.Sinks.File包：\nFile扩展方法：\npath参数\nrollingInterval参数：滚动间隔，RollingInterval枚举，按多久划分日志文件\nrollOnFileSizeLimit参数：文件太大时是否使用新文件\n\n\n\n\n\n静态Serilog日志记录器你可以为Log类的Logger属性注册一个日志记录器，它将成为全局可用的静态记录器。\nLog.Logger = logger;\n\n当你使用多个提供程序时，其中许多提供程序会在内存中缓冲日志，要把缓存实际刷新到每个提供程序，你可以执行Log.CloseAndFlush()或Log.CloseAndFlushAsync()以提高效率，避免频繁调用。\n将Serilog集成到ASP.NET Core应用程序将Serilog集成为内置日志记录器的一个提供程序，从而有效“接管”内置日志记录器。\n\n引入Serilog.AspNetCore包\n在builder.Host属性上调用UseSerilog扩展方法：\n\nbuilder.Host.UseSerilog();\n\n你可以通过设置静态Serilog日志记录器来配置Serilog日志记录器。\n将Serilog集成到非主机应用程序例如 Avalonia 桌面应用程序，直接使用 Log.Logger = new LoggerConfiguration() 初始化，在应用启动早期（Avalonia 的 App.OnFrameworkInitializationCompleted 之前或之内）完成配置，应用退出时显式调用 Log.CloseAndFlush()。\n用配置文件配置Serilog在 appsettings.json 中配置Serilog：\n&#123;\t&quot;Serilog&quot;: &#123;\t\t&quot;MinimumLevel&quot;: &#123;\t\t\t&quot;Default&quot;: &quot;Information&quot;,\t\t\t&quot;Override&quot;: &#123;\t\t\t\t&quot;Microsoft.AspNetCore&quot;: &quot;Warning&quot;\t\t\t&#125;\t\t&#125;,\t\t&quot;WriteTo&quot;: [\t\t\t&#123;\t\t\t\t&quot;Name&quot;: &quot;Console&quot;\t\t\t&#125;\t\t]\t&#125;&#125;\n\n由于已经在配置文件中完成了所有配置，你不需要在代码中硬编码任何配置，只需要导入配置文件：\nLog.Logger = new LoggerConfiguration()\t\t.ReadFrom.Configuration(builder.Configuration)\t\t.CreateLogger();\n\n\nbuilder.Configuration是ASP.NET Core应用程序的配置对象，通常包含appsettings.json文件\n\nSerilog日志功能增强Serilog.Enrichers包提供了许多丰富的功能增强，可以为日志事件添加更多上下文信息。\n\nSerilog.Enrichers.Environment包：添加环境信息\nSerilog.Enrichers.Thread包：添加线程信息\nSerilog.Enrichers.Process包：添加进程信息\n\n除此之外，你还可以通过Properties属性添加自定义属性。\n\n这里使用Json格式化器，以便你能够清晰地看到这些增强的属性。\n\n&#123;\t&quot;Serilog&quot;: &#123;\t\t&quot;MinimumLevel&quot;: &#123;\t\t\t&quot;Default&quot;: &quot;Information&quot;,\t\t\t&quot;Override&quot;: &#123;\t\t\t\t&quot;Microsoft.AspNetCore&quot;: &quot;Warning&quot;\t\t\t&#125;\t\t&#125;,\t\t&quot;WriteTo&quot;: [\t\t\t&#123;\t\t\t\t&quot;Name&quot;: &quot;Console&quot;,\t\t\t\t&quot;Args&quot;: &#123;\t\t\t\t\t&quot;formatter&quot;: &quot;Serilog.Formatting.Json.JsonFormatter, Serilog&quot;\t\t\t\t&#125;\t\t\t&#125;\t\t],\t\t&quot;Enrich&quot;: [ &quot;FromLogContext&quot;, &quot;WithMachineName&quot;, &quot;WithThreadId&quot;, &quot;WithProcessId&quot; ],\t\t&quot;Properties&quot;: &#123;\t\t\t&quot;Application&quot;: &quot;LoggingDemo&quot;,\t\t\t&quot;Environment&quot;: &quot;Development&quot;\t\t&#125;\t&#125;&#125;\n\n\n“FromLogContext“来自日志上下文，”WithMachineName“机器名，”WithThreadId“线程ID，”WithProcessId“进程ID\n\n&#123;&quot;Timestamp&quot;:&quot;2025-12-15T23:14:09.1705380+08:00&quot;,&quot;Level&quot;:&quot;Information&quot;,&quot;MessageTemplate&quot;:&quot;Now listening on: &#123;address&#125;&quot;,&quot;Properties&quot;:&#123;&quot;address&quot;:&quot;http://localhost:5050&quot;,&quot;EventId&quot;:&#123;&quot;Id&quot;:14,&quot;Name&quot;:&quot;ListeningOnAddress&quot;&#125;,&quot;SourceContext&quot;:&quot;Microsoft.Hosting.Lifetime&quot;,&quot;MachineName&quot;:&quot;RORMac&quot;,&quot;ThreadId&quot;:1,&quot;ProcessId&quot;:76483,&quot;Application&quot;:&quot;LoggingDemo&quot;,&quot;Environment&quot;:&quot;Development&quot;&#125;&#125;\n\n用配置文件配置Serilog.Sinks.ApplicationInsights&#123;\t&quot;Serilog&quot;: &#123;\t\t&quot;MinimumLevel&quot;: &#123;\t\t\t&quot;Default&quot;: &quot;Information&quot;,\t\t\t&quot;Override&quot;: &#123;\t\t\t\t&quot;Microsoft.AspNetCore&quot;: &quot;Warning&quot;\t\t\t&#125;\t\t&#125;,\t\t&quot;WriteTo&quot;: [\t\t\t&#123;\t\t\t\t&quot;Name&quot;: &quot;ApplicationInsights&quot;,\t\t\t\t&quot;Args&quot;: &#123;\t\t\t\t\t&quot;connectionString&quot;: &quot;your_connection_string&quot;,\t\t\t\t\t&quot;telemetryConverter&quot;: &quot;Serilog.Sinks.ApplicationInsights.Sinks.ApplicationInsights.TelemetryConverters.TraceTelemetryConverter, Serilog.Sinks.ApplicationInsights&quot;\t\t\t\t&#125;\t\t\t&#125;\t\t]\t&#125;&#125;\n\ntelemetryConverter参数指定了使用TraceTelemetryConverter，将日志作为跟踪数据发送到Application Insights。\nSerilog结构化日志在日志消息模板字符串的占位符的开头使用@符号，Serilog可以将对象序列化为结构化数据：\nlogger.Information(&quot;User details: &#123;@User&#125;&quot;, user);\n\n对于实现类似JS对象行为的字典Dictionary&lt;string, object&gt;，Serilog能理解这是一个字典，即使不加@符号也会将其展开为序列化结果：\nvar dict = new Dictionary&lt;string, object&gt;&#123;\t\t&#123; &quot;Name&quot;, &quot;Alice&quot; &#125;,\t\t&#123; &quot;Age&quot;, 30 &#125;,\t\t&#123; &quot;IsAdmin&quot;, true &#125;&#125;;logger.Information(&quot;User details: &#123;User&#125;&quot;, dict);\n\n[09:18:45 INF] User details: &#123;&quot;Name&quot;: &quot;Alice&quot;, &quot;Age&quot;: 30, &quot;IsAdmin&quot;: true&#125;\n\n如果你希望将字典作为单个对象记录，而不是展开为多个属性，可以使用$符号：\nlogger.Information(&quot;User details: &#123;$User&#125;&quot;, dict);\n\n[09:20:12 INF] User details: System.Collections.Generic.Dictionary`2[System.String,System.Object]\n\n尽管这是更小众的用法，但你应该知道你有这种能力，且它在某些情况下可能会有用。\nSerilog转换结构化数据如果你只想记录某个类型的某些特定字段，可以创建一个自定义转换器：\nvar logger = new LoggerConfiguration()\t\t.Destructure.ByTransforming&lt;Person&gt;(p =&gt; new &#123; p.Name, p.Age &#125;)\t\t.CreateLogger();\n\nSerilog添加自定义属性到日志上下文using (LogContext.PushProperty(&quot;UserId&quot;, userId))&#123;\tlogger.Information(&quot;User logged in.&quot;);&#125;\n\n&#123;&quot;Timestamp&quot;:&quot;2025-12-15T23:30:00.1234567+08:00&quot;,&quot;Level&quot;:&quot;Information&quot;,&quot;MessageTemplate&quot;:&quot;User logged in.&quot;,&quot;Properties&quot;:&#123;&quot;UserId&quot;:42&#125;&#125;\n\nSerilog记录操作耗时\n引入SerilogTimings包\n使用TimeOperation扩展方法记录操作耗时：\n\nusing (logger.TimeOperation(&quot;Processing order &#123;OrderId&#125;&quot;, orderId))&#123;\t// 模拟处理订单的操作\tawait Task.Delay(500);\tlogger.Information(&quot;Order &#123;OrderId&#125; processed.&quot;, orderId);&#125;\n\n你还可以控制操作成功或失败时的不同行为：\nvar operation = logger.TimeOperation(&quot;Processing order &#123;OrderId&#125;&quot;, orderId);try&#123;\tawait Task.Delay(500);\t/* 这是一段可能会抛出异常的业务代码 */\tif (timeout)\t&#123;\t\toperation.Abandon(); // 标记操作放弃\t\tlogger.Warning(&quot;Order &#123;OrderId&#125; processing timed out.&quot;, orderId);\t\treturn;\t&#125;\toperation.Complete(); // 标记操作成功\tlogger.Information(&quot;Order &#123;OrderId&#125; processed.&quot;, orderId);&#125;catch (Exception ex)&#123;\toperation.Fail(ex); // 标记操作失败\tlogger.Error(ex, &quot;Failed to process order &#123;OrderId&#125;.&quot;, orderId);&#125;\n\nSerilog屏蔽敏感数据\n引入Destructurama.Attributed包\n在LoggerConfiguration.Destructure属性上调用UsingAttributes方法：\n\nvar logger = new LoggerConfiguration()\t\t.Destructure.UsingAttributes()\t\t.CreateLogger();\n\n\n在需要屏蔽的属性上使用[LogMasked]注解：\n\npublic class User&#123;\tpublic string Name &#123; get; set; &#125;\t[LogMasked(Text = &quot;_MASKED_&quot;)]\tpublic string Email &#123; get; set; &#125;&#125;\n\n这样在日志中记录User对象时，Email属性将被屏蔽：\n[09:45:00 INF] User details: &#123;&quot;Name&quot;: &quot;Alice&quot;, &quot;Email&quot;: &quot;_MASKED_&quot;&#125;\n\n关于LogMasked注解：\n\nText属性：自定义用于替换敏感数据的文本\nShowFirst属性：显示明文的前几个字符，默认为0\nShowLast属性：显示明文的最后几个字符，默认为0\nPreserveLength属性：是否显示与明文长度匹配的*，默认为false\n\n或者使用[NotLogged]注解，Serilog将完全忽略该属性。\nSerilog异步处理Serilog的日志方法都是同步的，但储存日志需要时间，如果日志过多，调用线程将明显阻塞。这意味着，实际的Serilog日志记录器在幕后并不会同步执行工作，而是尽可能缓冲，然后异步地将日志推送到提供程序，或者说接收器（sink）。如何实现这个机制？\nSerilog.Sinks.Async包提供了一个异步接收器，可以异步地将日志写入另一个接收器，从而提高性能。这意味着，它可以为任何接收器提供异步处理能力，即使这些接收器本身是同步的。\n以异步方式注册File接收器，从而提高日志写入文件的性能：\nvar logger = new LoggerConfiguration()\t\t.WriteTo.Async(x =&gt; x.File(&quot;log.txt&quot;), 10)\t\t.CreateLogger();\n\n这时，Serilog会将日志消息放入缓冲区，在缓冲区满时异步地将它们写入文件。这里的10就表示缓冲区的大小为10条日志消息。如果你不指定缓冲区大小，Serilog也会保证日志的周期性写入。\n在应用程序关闭时，调用Log.CloseAndFlush()确保所有缓冲的日志都写入接收器。\n自定义Sink实现ILogEventSink接口以自定义Sink，通常会聚合一个可空的IFormatProvider，以便在需要时格式化日志消息。\npublic class MyCustomSink : ILogEventSink&#123;\tprivate readonly IFormatProvider? _formatProvider;\tpublic MyCustomSink(IFormatProvider? formatProvider)\t&#123;\t\t_formatProvider = formatProvider;\t&#125;\tpublic MyCustomSink() : this(null) &#123;&#125;\tpublic void Emit(LogEvent logEvent)\t&#123;\t\t// 处理日志事件，例如将其写入自定义存储\t\tvar message = logEvent.RenderMessage(_formatProvider);\t\tConsole.WriteLine($&quot;log from MyCustomSink: &#123;message&#125;&quot;);\t&#125;&#125;\n\n\nRenderMessage方法：使用可选的格式提供程序渲染日志消息\n\n然后，在LoggerConfiguration.WriteTo属性上调用Sink&lt;TSink&gt;方法（前提是MyCustomSink有无参构造）：\nvar logger = new LoggerConfiguration()\t\t.WriteTo.Sink&lt;MyCustomSink&gt;()\t\t.CreateLogger();\n\n或者调用Sink(ILogEventSink sink)方法，并使用MyCustomSink的有参构造，更灵活：\nvar logger = new LoggerConfiguration()\t\t.WriteTo.Sink(new MyCustomSink(someFormatProvider))\t\t.CreateLogger();\n\n如果你想跟其他Sinks提供一致的使用体验，可以创建LoggerSinkConfiguration的扩展方法（推荐）：\npublic static class MyCustomSinkExtensions&#123;\tpublic static LoggerConfiguration MyCustomSink(this LoggerSinkConfiguration loggerConfiguration,\t\tIFormatProvider? formatProvider = null)\t&#123;\t\treturn loggerConfiguration.Sink(new MyCustomSink(formatProvider));\t&#125;&#125;\n\nvar logger = new LoggerConfiguration()\t\t.WriteTo.MyCustomSink()\t\t.CreateLogger();\n","categories":["编程","C#技术栈",".NET日志"]},{"title":".NET多线程(1)：多线程基础","url":"/2026/01/25/dotnet-multithreading-1-basic/","content":"这几篇.NET多线程笔记写于2025年11月底-12月初。\n进程、线程与线程调度器\n进程 (process)：一个应用程序包含一个或多个进程，每个进程包含一个或多个线程\n线程 (thread)：线程是CPU工作的基本单位，CPU只能看到一个个线程\n线程调度器 (thread scheduler)：一块CPU核心同一时刻只能执行一条线程，因此需要调度器管理线程的执行\n线程调度器是操作系统的一部分，应用程序开发者不可控制\n\n\n时间片：由操作系统分配的每个线程一次占据CPU的时间，每轮每条线程的时间片执行完后重新分配\n\n主线程与工作线程：\n\n主线程：每个应用进程至少有一个主线程\n工作线程：应用进程中主线程之外的其他线程\n\n单线程进程与多线程进程：\n\n单线程进程：只有一个主线程的进程\n多线程进程：拥有一个主线程和多个工作线程的进程\n\n为什么要使用多线程？\n并发：对于多核的CPU，同一时刻会有多条线程在不同的CPU核心上并发地执行\n单核CPU没有真正的并发，它的多任务场景只是极快速地交替执行多个线程\n\n\n多线程实现“分而治之” (divide and conquer)：把数组的累加工作分成多份，交给不同的线程完成\n阻塞：使用Join方法，让被调线程阻塞主调线程，直到阻塞队列执行完毕，主调线程才能继续执行\n用工作线程卸载 (offload) 长时间运行的任务：否则它将阻塞主线程（在GUI应用中就是UI线程，从而导致UI长时间未响应，对用户不友好）\n\n","categories":["编程","C#技术栈",".NET多线程"]},{"title":".NET日志(4)：性能优化","url":"/2025/12/17/dotnet-logging-4-performance/","content":"日志是一个切面关注点，日志的记录会影响整个系统的性能。在程序的热点路径上，日志记录的开销可能会显著影响应用程序的响应时间和吞吐量，这些日志必须非常轻量、非常高效。\n使用日志消息模板字符串时，为了结构化日志，每记录一条日志，日志记录器都需要创建这些参数的数组，并对参数装箱（因为是object[]数组）。日志一多，会造成大量内存开销。要优化它，可以使用LoggerMessage.Define方法来预定义日志消息模板，从而避免在每次记录日志时的装箱和数组分配。\nprivate static readonly Action&lt;ILogger, int, Exception?&gt; _logUserLoggedIn =    LoggerMessage.Define&lt;int&gt;(LogLevel.Information,      new EventId(1, nameof(UserLoggedIn)),      &quot;User &#123;UserId&#125; has logged in.&quot;);public void UserLoggedIn(int userId)&#123;  /* 一些业务代码 */  _logUserLoggedIn(_logger, userId, null);&#125;\n\n\nAction委托使用泛型以强类型参数传入（如 int），减少装箱并更易被JIT优化&#x2F;内联。\nDefine方法内部会对每种不同参数个数的消息模板使用特定格式化器，避免了数组分配。\n&quot;User {UserId} has logged in.&quot;是一个编译时常量，会在内存中驻留（interned）。\n\n这种写法比较繁琐，要解决这个问题，使用Source Generator（源代码生成器，由Microsoft.Extensions.Logging.Generators提供）在编译时生成代码，你只需使用LoggerMessage注解声明ILogger的扩展方法：\npublic static partial class LoggerExtensions&#123;    [LoggerMessage(EventId = 1, Level = LogLevel.Information, Message = &quot;User &#123;UserId&#125; has logged in.&quot;)]    public static partial void LogUserLoggedIn(this ILogger logger, int userId);&#125;\n\n通过阅读LoggerMessage注解，Source Generator会生成类似上面使用LoggerMessage.Define的代码，从而实现性能优化，同时让开发体验更好。\n使用时，可以直接调用LogUserLoggedIn扩展方法：\npublic void UserLoggedIn(int userId)&#123;  /* 一些业务代码 */  _logger.LogUserLoggedIn(userId);&#125;\n","categories":["编程","C#技术栈",".NET日志"]},{"title":".NET多线程(2)：线程同步","url":"/2026/01/25/dotnet-multithreading-2-synchronization/","content":"\n共享资源：并发的线程竞争共享资源，造成冲突和资源争抢\n\n非原子操作与原子操作：\n\n非原子操作：可以拆分的操作，如 count++ 实则为先 temp+1 再赋值给 count，缓存天然缺乏时效性，造成不一致行为和竞态条件\n原子操作：不可拆分的操作，调度器不能中断它而去执行其他线程\n\n临界区与线程同步：\n\n临界区 (critical section)：线程中访问共享资源的操作区域，它应该是原子的\n线程同步 (thread synchronization)：解决资源争抢的问题，你方唱罢我登场（舞台是共享的）\n\n非原子操作为什么导致不一致行为？\n你缓存A的值，还未加1，分配给你的时间片就到了，于是调度器将你挂起，让我执行\n我给A加了1，调度器再让你执行，这时你的缓存已经丢失了时效性，你现在是给过去的A加1，再赋值给现在的A，污染了现在的A\n\n两种常见的锁机制：写锁和读锁\n排它锁&#x2F;写锁&#x2F;X锁 (Exclusive Lock)：当一个线程持有写锁时，其他线程既不能获取写锁，也不能获取读锁\n共享锁&#x2F;读锁&#x2F;S锁 (Shared Lock)：当一个线程持有读锁时，其他线程不能获取写锁，只能获取读锁\n\n如果一个线程不能获取它想要的锁，它将阻塞并等待该锁释放；例如：线程获取读锁时，如果有其他线程持有写锁，则阻塞\n.NET线程同步的4个实现lock关键字（写锁）lock(锁对象) { 锁主体(通常是临界区) }\n锁主体同时只能由一个线程执行，即持有锁对象的线程；锁主体表现的就像是原子操作\n\n在 .NET 8&#x2F;C# 12（含）以前，使用一个object对象当作锁对象即可\n在 .NET 9&#x2F;C# 13（含）以后，有专门的System.Threading.Lock对象\n\n锁主体中隐含try-finally机制，在finally中会释放锁对象，因此不必担心锁主体抛出异常，导致锁对象无法释放\n监视器 Monitor（写锁）\n监视器：监视临界区，如果有一个线程进入临界区，就让其他线程阻塞等待\nlock关键字是监视器的语法糖，因此监视器可以提供比lock更细粒度的控制\n\n\nMonitor.Enter(锁对象)：进入临界区，如果锁对象已经被持有，就阻塞等待（如果锁一直得不到释放，会导致无限等待）\nMonitor.Exit(锁对象)：退出临界区，释放锁对象\n使用try-finally机制，在finally中调用Exit方法，以确保始终释放锁对象（监视器需要手动释放锁对象）\n\n\nMonitor.TryEnter(锁对象,等待时间) ：如果锁对象被持有，就先等待一段时间；如果时间到了锁还是没有释放，就返回false，你可据此设计请求超时的分支逻辑；否则返回true（不会导致无限等待，或长时间等待，这会让用户无所适从，对用户不友好）\n\n互斥锁 Mutex（写锁）\n互斥锁是写锁的一种跨进程实现，而监视器只能在同一进程内使用\n互斥锁在操作系统中使用，因此需要保证其名称进程间唯一\n创建互斥锁比创建监视器需要更多资源，除非你需要跨进程同步，否则不应使用互斥锁\n\n\n互斥锁构造器：new Mutex(false, &quot;GlobalMutex&quot;)\n参数1：初始所有权\n参数2：互斥锁名称，只有命了名的互斥锁才能跨进程共享\n\n\nMutex对象使用非托管资源（不由编译器托管），需要程序自行释放；创建对象时，使用using关键字让编译器帮你在合适的时机释放它：using var mutex = new Mutex()\nWaitOne方法：阻塞等待以获取该互斥锁\nReleaseMutex方法：释放该互斥锁（这不是从内存释放Mutex对象！）\n\n读写锁 ReaderWriterLock（写锁&amp;读锁）\nReaderWriterLockSlim类（ReaderWriterLock类的精简改进版）\n获取&#x2F;释放写锁：(Try)EnterWriteLock和ExitWriteLock方法\n获取&#x2F;释放读锁：(Try)EnterReadLock和ExitReadLock方法\n\n\nReaderWriterLockSlim对象使用非托管资源，使用using避免内存泄漏\n\n","categories":["编程","C#技术栈",".NET多线程"]},{"title":".NET多线程(3)：线程交互","url":"/2026/01/26/dotnet-multithreading-3-interaction/","content":"信号量 Semaphore\n信号量主要用于控制并发线程或进程（指定名称）的个数，一般不用于保护临界区\nSemaphoreSlim类（Semaphore类的精简版，没有跨进程功能，后者有）\n参数：initialCount：初始个数；maxCount：最大个数；倒计数，每次获取时减1\n\n\nWait方法：获取一个信号量，如果信号量不足，则阻塞\nRelease方法：释放一个信号量\nWait和Release不必在同一线程中（信号量不具有线程亲和性）\nSemaphoreSlim对象使用非托管资源，使用using避免内存泄漏\n在Web服务器示例中，在请求队列的监控线程获取信号量，并在请求处理线程释放信号量，实现有限个监控线程并发（这里信号量不用于保护临界区，因此别忘了给入队出队的逻辑加写锁）\n\n自动重置事件 AutoResetEvent\n自动重置事件用于信号传递（Signaling）\n典型应用：生产者-消费者场景\n生产者线程生产了足够资源时，向消费者线程传递布尔类型信号\n如果生产者足够快，消费者线程就能并发\n但如果生产者过于快，就会造成资源浪费，为此你需要把产品放入队列中\n\n\n构造器参数：bool initialState：初始状态，如果初始时已经有资源，可以设为true\nWaitOne方法：等待信号，阻塞\nSet方法：设置信号\nAutoResetEvent对象使用非托管资源，使用using避免内存泄漏\n\n手动重置事件 ManualResetEvent\n在自动重置事件中，一旦有线程持有信号，信号将自动重置；而在手动重置事件中，你需要调用Reset方法手动重置信号\n典型应用：在分治法中，每次都需要多个工作线程并发运行\n\n","categories":["编程","C#技术栈",".NET多线程"]},{"title":".NET日志(5)：监控与告警","url":"/2025/12/18/dotnet-logging-5-monitoring-and-alerting/","content":"监控涉及系统中的事件或指标，并基于这些数据采取行动，主要目的是为了及时发现并告警系统异常、性能瓶颈或业务逻辑问题。任何停机、任何严重错误、任何95%的性能下降等问题，都能基于基于推送至某一平台的日志非常容易地检测到，每个具备一定监控能力的平台都会有自己的告警系统。\n在Application Insights中，监视器（Monitor）-告警（Alerts）允许用户基于日志数据创建监控规则，并在满足特定条件时触发告警通知。告警规则可以基于各种指标和日志查询来定义，例如响应时间、错误率、请求数量等。\n\n","categories":["编程","C#技术栈",".NET日志"]},{"title":".NET多线程(4)：线程安全","url":"/2026/01/26/dotnet-multithreading-4-safety/","content":"线程亲和性 Thread Affinity\n在工作线程中访问主线程中的资源时，需要同步上下文\n主线程中的资源一般会提供Invoke方法\nInvoke方法：传递委托，委托的方法体上下文就是同步上下文\nInvokeRequired属性：是否需要调用Invoke方法；如果方法是在主线程调用，那么就不能用Invoke方法\n\n线程安全 Thread Safety当一个函数、数据结构或类可以被多个线程并发使用，而不会产生竞态条件、不一致行为或数据损坏时，它就是线程安全的。\n\n线程安全的语法实体内部已经使用了适当的同步机制，使用它们时不需要另外采取线程同步措施。\n\n线程的生命周期线程的生命周期开始于 System.Threading.Thread类的实例被创建时，结束于线程被终止或执行完成时。\n\n未启动状态：当线程实例被创建，但Start方法未被调用时\n就绪状态：当线程准备好运行，并等待CPU周期时\n不可运行状态：调用了Sleep方法；调用了Wait方法；通过I&#x2F;O操作阻塞\n死亡状态：当线程已经执行完毕，或已经终止时\n\n让线程等待一段时间\nThread.Sleep(毫秒数)：线程将被调度器踢出CPU，为不可运行状态，即WaitSleepJoin状态\nThread.SpinWait(次数)：相当于for循环，线程会被保持在CPU内，只是繁忙等待；但如果占用CPU时间太长，超过分配时间片，仍会被调度器踢出\nSpinWait.SpinUntil(条件,超时毫秒数)：繁忙等待，直到满足条件或超时\n后两种方法谨慎使用，小心耗尽CPU资源\n\n从线程中返回结果\nThread类没有内置的方法返回结果，更好的选择是Task类\nThread类返回结果的唯一方式是共享变量\n\n线程取消 Thread Cancellation\n设置一个共享的标志变量，如 bool cancelThread\n更好的做法：CancellationTokenSource类，详见任务取消\n\n线程池 Thread Pool\n创建和释放线程需要时间和空间，每次都创建新的性能很差\n每个应用程序都有一个线程池，并定义了最大和最小线程数\n\n线程池的行为：\n\n达到最小值之前，每次都创建新线程\n达到最小值之后，每次用空闲的，只有都繁忙，才创建新线程\n达到最大值之后，如果都繁忙，只能排队等待空闲线程\n\n工作线程的异常处理\n每个线程都有自己的调用堆栈，工作线程抛出的异常永远不会到达主线程\n简单的做法是在工作线程内使用try-catch块，并自行处理\n更好的做法是使用共享资源，创建一个异常列表 List&lt;Exception&gt;，在工作线程中catch异常并将其加入列表，并在主线程统一处理\n更更好的做法是使用Task类，它有内置的异常处理机制\n\n","categories":["编程","C#技术栈",".NET多线程"]},{"title":".NET多线程(5)：异步编程","url":"/2026/01/27/dotnet-multithreading-5-asynchronous/","content":"多线程 vs. 异步编程\n多线程与异步编程二者本质上相同，只是侧重点不同\n多线程侧重于分而治之的场景，异步编程侧重于卸载长时间运行的任务（详见为什么要使用多线程）\n多线程适用于CPU密集型操作，异步编程适用于I&#x2F;O密集型操作\nI&#x2F;O操作：访问本地文件、访问数据库、访问互联网\n\nTask类\n构造器：new Task(委托)\nStart方法\n更常见的写法：var task = Task.Run(委托)\nTask对象中封装了许多实用数据和功能\n使用Task.Delay(毫秒数)，而不是Thread.Sleep(毫秒数)\n\nThread类 vs. Task类\nTask是一个承诺（Promise）：它不一定涉及线程，只是承诺在未来某个时间完成任务\n推荐使用Task类而不是Thread类，因为Task类是更高级别的抽象，开箱即用，而Thread类更底层\n默认使用线程池；从任务中返回结果；简单的任务延续；更好异常处理\nAsync&#x2F;Await：使编写异步代码像编写同步代码一样；便于同步上下文，解决线程亲和性问题\n\n\n\n从任务中返回结果\nTask.Run(委托)返回的Task&lt;T&gt;中的泛型T就是返回值类型\nResult属性：委托方法的返回值\n\n任务阻塞 Task Blocking\nWait方法：阻塞调用线程，直到任务完成\nWaitAll静态方法：阻塞调用线程，直到所有任务完成\nResult属性：阻塞调用线程，直到任务完成并返回结果\n\n任务延续 Task Continuation\nContinueWith方法：创建一个工作线程，执行传入的委托，委托提供主调Task对象的参数\n\nWhenAll静态方法：接收并返回Task数组，表示当所有Task完成时\n\nWhenAny静态方法：接收Task数组，返回Task，表示当任一Task完成时\n\n配合ContinueWith或await使用，让When返回的任务实际运行起来\n\n延续链（continuation chain）：你可以链式使用ContinueWith，形成一条任务链 Task&lt;Task&lt;string&gt;&gt;\n\n拆包装（unwrap）：但你并不想要 Task&lt;Task&lt;string&gt;&gt; 这种套娃的怪东西，因此需要用到Unwrap方法，它将执行里面的Task，并返回Task&lt;string&gt;\n\nUnwrap也是非阻塞的，它会在工作线程中执行相关操作\n\n\n任务的异常处理\n任务中的异常是隐藏的，不会影响主线程继续运行\n\n对任务使用外部try-catch不起作用\n\n任何在委托外部的try-catch都是无稽之谈，因为委托一般不会就地执行\n\n\n异常存储在任务本身中：Status属性（异常时值为Faulted故障）和Exception属性（System.AggregateException类，存储所有异常）\n\n可以迭代这些异常：task.Exception.InnerExceptions属性\n\n使用Wait或Result：抛出任务的AggregateException\n\nContinueWith方法有个重载，第二个参数为TaskContinuationOptions枚举，设置为NotOnFaulted就会抛出AggregateException\n\n使用await：如果有任何异常，直接抛出，不再延续执行\n\n\n任务同步 Task Synchronization\n任务同步和线程同步的办法完全一样\n任务同步：lock关键字、监视器、互斥锁和读写锁\n任务交互：信号量、自动重置事件和手动重置事件\n\n任务取消 Task Cancellation\n任务取消和线程取消的办法别无二致\n设置一个共享的标志变量，如 bool cancelTask\n更好的做法：CancellationTokenSource类（非托管资源，使用using）\n获取令牌：Token属性（CancellationToken类）\n请求取消：Cancel方法\n是否请求取消：IsCancellationRequested属性\n超时取消：CancelAfter方法，若取消，应抛出OperationCanceledException；为此，推荐使用ThrowIfCancellationRequested方法\n异步方法API通常都有个重载接收CancellationToken来实现取消异步操作，如HttpClient类GetStringAsync方法的第二个参数\n\n\n\nAsync &amp; Await\n使用async修饰异步方法，并在异步任务前加await，使编写异步代码看起来就像在编写同步代码\n\n当你在主线程调用异步方法时，它将在一个工作线程中异步执行\n\n在异步方法中，await之后的所有内容都是异步任务的延续\n\nawait之前的内容在主线程上执行，之后的内容在工作线程上执行\n\n\n当程序运行到await关键字时，调用线程立即被释放，它可以自由地继续运行\n\nawait将返回任务的结果，而不是结果的任务\n\n使用async和await会自动管理同步上下文，await的延续代码将在同步上下文中执行\n\n异步方法返回结果的任务，如果方法体返回int，则异步方法返回Task&lt;int&gt;；如果方法体没有返回值，则异步方法返回Task\n\n如果将异步方法的返回值类型设置为void，将不能在后续应用Task特性，不能用await；除非你在编写程序入口方法或实现外部API方法等不需要在后续用上Task特性的方法，否则不推荐这么做\n\n异步方法的命名约定：在名称后加Async后缀，如FetchDataAsync\n\n\nAwait到底做了什么？\n编译器会创建一个状态机对象，并以每个await语句作为段落结尾，来划分状态\n每个状态都会记录当前状态和变量集合，并捕获同步上下文\n每完成一个状态，它会调用moveNext方法，在捕获到的同步上下文中执行下一个状态\n通过状态集合执行包含多个await的异步方法\n\n","categories":["编程","C#技术栈",".NET多线程"]},{"title":".NET多线程(6)：并行循环","url":"/2026/01/27/dotnet-multithreading-6-parallel-loop/","content":"\n并行循环（parallel loop）：Parallel.For(int 起点含, int 终点不含, Action 循环体委托)\n这将在不同线程中共享循环体的资源，你需要上锁实现同步访问\nFor：有序集合；ForEach：无序集合+有序集合\nParallel.Invoke(委托集合)：并行运行委托集合的所有方法\n循环任务必须足够繁重（串行性能非常差），才适合并行循环\n\n并行循环的原理\n数据分区：分治法，把集合分成特定个部分，并创建等量的线程\n主要使用线程池线程\n试图替开发者做出最佳决策\n阻塞调用，不需要Wait\n\n并行循环的异常处理\n如果有任何一个线程出现异常，则所有线程不会进入下一次迭代\n所有异常将组合为一个AggregateException抛出，在并行循环外部try-catch\n并行任务通常都会将所有线程的异常组合为一个聚合异常抛出\n如果每次迭代的耗时较长，当一个线程异常时，你想要立即停止其他线程，可以使用两个参数的委托的重载，第二个参数就是并行循环的当前状态，其IsExceptional属性指出了是否有线程出现异常，以便快速退出本次迭代\n\n并行循环的主动干预\n状态的Stop方法和IsStopped属性配合使用，可以主动停止各线程\n状态的Break方法和ShouldExitCurrentIteration（应该退出当前迭代）、LowestBreakIteration（Break的线程中最小的迭代位置）属性配合使用，可以使整体集合完整迭代到特定位置停止：\nif (state.ShouldExitCurrentIteration &amp;&amp; state.LowestBreakIteration &lt; i) return;\n\n\n\nBreak方法怎么使并行循环“完整地”迭代到特定进度？\n0到100遍历，分成3个线程：0-33、33-66、66-100\n线程1到30、线程2到60、线程3到90时，线程2和3的状态调用Break，它们立即退出，此时ShouldExitCurrentIteration为true， LowestBreakIteration为60\n线程1的i&#x3D;30&lt;LowestBreakIteration，所以它继续执行直到完成\n最后，整体迭代进度停留在60\n\n为什么Break时选用LowestBreakIteration？\nBreak的线程将立即退出，这意味着该线程负责的部分永远无法迭代完成\n最小的迭代位置 (LowestBreakIteration) 意味着负责它前面那些部分的线程没有Break\n等到这些线程完成迭代，整体迭代进度到达最小迭代位置\n这是符合Break语义的：迭代到65退出 &amp;&amp; 迭代到80退出 == 迭代到65退出，65是最小迭代位置\n\n并行循环结果 ParallelLoopResult\n当你接收并行循环返回的结果时，它是阻塞的\nIsCompleted属性：是否迭代完成\nLowestBreakIteration属性：Break的线程中最小的迭代位置；如果是因为Stop或抛出异常停止迭代，则它的值为null\n\n并行循环取消\n使用ParallelOptions和CancellationTokenSource类\nnew ParallelOptions { CancellationToken = cts.Token }\nParallel.For(0, 1000, options, 循环体委托)\n当调用token.Cancel()时，Parallel.For抛出TaskCanceledException\n\n并行循环中的线程本地存储\n线程本地存储（thread local storage）：每个线程自己内部使用的变量；分治法\nParallel.For(0, 100, lcoalInit, (i,state,tls)=&gt;{}, localFinally)\nlocalInit参数：委托，初始化tls并返回\nlocalFinally参数：委托，线程完成枚举时处理tls，依然是线程的一部分，使用共享资源时需要加锁同步\n\n\n\n","categories":["编程","C#技术栈",".NET多线程"]},{"title":".NET多线程(7)：并行LINQ（PLINQ）","url":"/2026/01/27/dotnet-multithreading-7-plinq/","content":"\n集合的数据量非常庞大时，适合使用并行LINQ（PLINQ）\nAsParallel方法：获取集合的ParallelQuery对象，然后就可以像使用一般LINQ一样使用PLINQ，如items.AsParallel().Where(...)\nParallelQuery的AsOrdered方法：在并行处理的同时保持顺序，这肯定会降低性能，但重要的是搞清楚你的需求\nParallelQuery的ForAll方法：对并行查询集合的每个元素做特定处理\n\nPLINQ工作原理\nPLINQ工作原理：生产者-缓冲区-消费者\n\n自定义缓冲区大小： ParallelQuery的WithMergeOptions方法、ParallelMergeOptions枚举\n\nNotBuffered：不缓冲，一生产就消费；但仍然有缓冲区，因为生产消费速度不一致；一次仍然可能生产多个产品，只是不设不可消费的阈值\nFullyBuffered：消费之前完全缓冲，先完成所有生产工作再消费\n\n\nMerge：将所有数据分区合并成一个\n\nforeach遍历中存在合并行为：foreach在主线程消费，PLINQ需要先在工作线程合并生产集合，再给到主线程\n\nForAll遍历中不存在合并行为：同一个工作线程同时用于生产和消费，此时FullyBuffered不起作用\n\n如果你有些任务不需要合并集合，你应该用ForAll遍历\n\n这在一定程度上替代了Stream流的功能\n\n\nForAll方法会抛出聚合异常，在这样的消费者外部使用try-catch\n\n对于聚合异常，可以使用Handle方法，传入异常处理委托，这将遍历InnerExceptions集合，最后需要返回是否处理成功的布尔值\n\n使用WithCancellation方法来使用取消令牌：当令牌取消时，所有线程将尽快退出，已经进入的迭代仍会完成\n\n操作取消异常OperationCanceledException不会放到聚合异常中\n\n\nPLINQ的性能考虑如果迭代任务不是过于繁重，则PLINQ的性能不如LINQ；因为对于较为轻松的工作，创建、启动线程等线程相关操作耗时太长。\n","categories":["编程","C#技术栈",".NET多线程"]},{"title":".NET多线程(8)：并发数据结构","url":"/2026/01/27/dotnet-multithreading-8-concurrent-data-structures/","content":"并发栈 ConcurrentStack\n并发数据结构为多线程设计，内部支持线程同步（是线程安全的），不必自己加锁\n可以像使用常规栈那样使用并发栈，但出栈时只能用TryPop方法\n其他并发数据结构大同小异，它们都实现为生产消费量身定制的IProducerConsumerCollection&lt;T&gt;接口，不做赘述\n\n阻塞集合 BlockingCollection\n阻塞集合是个包装器，用于包装并发数据结构，主要作用于生产消费场景中的缓冲区\n\n阻塞 (Blocking) 和边界 (Bounding)\n\n上限阻塞：缓冲区达到上限时生产者阻塞，等待消费\n下限阻塞：缓冲区为空时，消费者阻塞，等待生产\n\n\n构造器：第二个参数是阻塞上限\n\nGetConsumingEnumerable方法：获取自动下限阻塞的枚举器，因此foreach将不停地消费下去，永无止境（如果没有元素foreach就阻塞，而不会退出）\n\n输入缓冲区：操作系统本身有一个输入缓冲区，因为阻塞上限阻塞的输入就在输入缓冲区排队\n\nCompleteAdding方法：将集合标记为已完成\n\nIsCompleted属性：集合是否标记为已完成\n\n使用上面两个成员让foreach主动退出\n\nChannel类：.NET Core 3.0+ 推出的高性能生产者-消费者队列（比 BlockingCollection 更适合异步场景）\n\n\n通道 Channel\nChannel是ConcurrentQueue并发队列的包装器\n\nCreatUnbounded静态方法：无边界的，适用于生产慢于消费，或有限生产\n\nCreatBounded静态方法：有边界的，适用于生产快于消费\n\nBoundedChannelOptions类：\n\nFullMode&#x3D;通道满了怎么办：Wait&#x3D;阻塞生产；DropNewest&#x3D;丢掉最新；DropOldest&#x3D;丢掉最老；DropWrite&#x3D;丢掉当前\nSingleReader&#x3D;是否只能有一个消费者；SingleWriter&#x3D;是否只能有一个生产者\n\n\n同步方法：\n\nChannelWriter.TryWrite方法：out输出写入的资源，本身返回是否成功\nChannelReader.TryRead方法：同上理\n\n\n异步方法：\n\nChannelWriter.WriteAsync方法\nChannelReader.ReadAsync方法\n\n\n\n","categories":["编程","C#技术栈",".NET多线程"]}]