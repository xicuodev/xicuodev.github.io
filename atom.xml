<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>系错的技术博客</title>
  
  <subtitle>好用、美观</subtitle>
  <link href="https://blog.xicuodev.top/atom.xml" rel="self"/>
  
  <link href="https://blog.xicuodev.top/"/>
  <updated>2026-01-27T10:29:41.913Z</updated>
  <id>https://blog.xicuodev.top/</id>
  
  <author>
    <name>xicuod</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>.NET多线程(8)：并发数据结构</title>
    <link href="https://blog.xicuodev.top/2026/01/27/dotnet-multithreading-8-concurrent-data-structures/"/>
    <id>https://blog.xicuodev.top/2026/01/27/dotnet-multithreading-8-concurrent-data-structures/</id>
    <published>2026-01-27T10:27:25.962Z</published>
    <updated>2026-01-27T10:29:41.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发栈-ConcurrentStack"><a href="#并发栈-ConcurrentStack" class="headerlink" title="并发栈 ConcurrentStack"></a>并发栈 <code>ConcurrentStack</code></h2><ul><li>并发数据结构为多线程设计，内部支持线程同步（是线程安全的），不必自己加锁</li><li>可以像使用常规栈那样使用并发栈，但出栈时只能用<code>TryPop</code>方法</li><li>其他并发数据结构大同小异，它们都实现为生产消费量身定制的<code>IProducerConsumerCollection&lt;T&gt;</code>接口，不做赘述</li></ul><h2 id="阻塞集合-BlockingCollection"><a href="#阻塞集合-BlockingCollection" class="headerlink" title="阻塞集合 BlockingCollection"></a>阻塞集合 <code>BlockingCollection</code></h2><ul><li><p>阻塞集合是个包装器，用于包装并发数据结构，主要作用于生产消费场景中的缓冲区</p></li><li><p>阻塞 (Blocking) 和边界 (Bounding)</p><ul><li>上限阻塞：缓冲区达到上限时生产者阻塞，等待消费</li><li>下限阻塞：缓冲区为空时，消费者阻塞，等待生产</li></ul></li><li><p>构造器：第二个参数是阻塞上限</p></li><li><p><code>GetConsumingEnumerable</code>方法：获取自动下限阻塞的枚举器，因此<code>foreach</code>将不停地消费下去，永无止境（如果没有元素<code>foreach</code>就阻塞，而不会退出）</p></li><li><p>输入缓冲区：操作系统本身有一个输入缓冲区，因为阻塞上限阻塞的输入就在输入缓冲区排队</p></li><li><p><code>CompleteAdding</code>方法：将集合标记为已完成</p></li><li><p><code>IsCompleted</code>属性：集合是否标记为已完成</p></li><li><p>使用上面两个成员让<code>foreach</code>主动退出</p></li><li><p><code>Channel</code>类：.NET Core 3.0+ 推出的高性能生产者-消费者队列（比 <code>BlockingCollection</code> 更适合异步场景）</p></li></ul><h2 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道 Channel"></a>通道 <code>Channel</code></h2><ul><li><p><code>Channel</code>是<code>ConcurrentQueue</code>并发队列的包装器</p></li><li><p><code>CreatUnbounded</code>静态方法：无边界的，适用于生产慢于消费，或有限生产</p></li><li><p><code>CreatBounded</code>静态方法：有边界的，适用于生产快于消费</p></li><li><p><code>BoundedChannelOptions</code>类：</p><ul><li><code>FullMode</code>&#x3D;通道满了怎么办：<code>Wait</code>&#x3D;阻塞生产；<code>DropNewest</code>&#x3D;丢掉最新；<code>DropOldest</code>&#x3D;丢掉最老；<code>DropWrite</code>&#x3D;丢掉当前</li><li><code>SingleReader</code>&#x3D;是否只能有一个消费者；<code>SingleWriter</code>&#x3D;是否只能有一个生产者</li></ul></li><li><p>同步方法：</p><ul><li><code>ChannelWriter.TryWrite</code>方法：<code>out</code>输出写入的资源，本身返回是否成功</li><li><code>ChannelReader.TryRead</code>方法：同上理</li></ul></li><li><p>异步方法：</p><ul><li><code>ChannelWriter.WriteAsync</code>方法</li><li><code>ChannelReader.ReadAsync</code>方法</li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;并发栈-ConcurrentStack&quot;&gt;&lt;a href=&quot;#并发栈-ConcurrentStack&quot; class=&quot;headerlink&quot; title=&quot;并发栈 ConcurrentStack&quot;&gt;&lt;/a&gt;并发栈</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET多线程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET多线程(7)：并行LINQ（PLINQ）</title>
    <link href="https://blog.xicuodev.top/2026/01/27/dotnet-multithreading-7-plinq/"/>
    <id>https://blog.xicuodev.top/2026/01/27/dotnet-multithreading-7-plinq/</id>
    <published>2026-01-27T10:18:48.518Z</published>
    <updated>2026-01-27T10:29:34.151Z</updated>
    
    <content type="html"><![CDATA[<ul><li>集合的数据量非常庞大时，适合使用并行LINQ（PLINQ）</li><li><code>AsParallel</code>方法：获取集合的<code>ParallelQuery</code>对象，然后就可以像使用一般<code>LINQ</code>一样使用<code>PLINQ</code>，如<code>items.AsParallel().Where(...)</code></li><li><code>ParallelQuery</code>的<code>AsOrdered</code>方法：在并行处理的同时保持顺序，这肯定会降低性能，但重要的是搞清楚你的需求</li><li><code>ParallelQuery</code>的<code>ForAll</code>方法：对并行查询集合的每个元素做特定处理</li></ul><h2 id="PLINQ工作原理"><a href="#PLINQ工作原理" class="headerlink" title="PLINQ工作原理"></a>PLINQ工作原理</h2><ul><li><p>PLINQ工作原理：生产者-缓冲区-消费者</p></li><li><p>自定义缓冲区大小： <code>ParallelQuery</code>的<code>WithMergeOptions</code>方法、<code>ParallelMergeOptions</code>枚举</p><ul><li><code>NotBuffered</code>：不缓冲，一生产就消费；但仍然有缓冲区，因为生产消费速度不一致；一次仍然可能生产多个产品，只是不设不可消费的阈值</li><li><code>FullyBuffered</code>：消费之前完全缓冲，先完成所有生产工作再消费</li></ul></li><li><p><code>Merge</code>：将所有数据分区合并成一个</p></li><li><p><code>foreach</code>遍历中存在合并行为：<code>foreach</code>在主线程消费，PLINQ需要先在工作线程合并生产集合，再给到主线程</p></li><li><p><code>ForAll</code>遍历中不存在合并行为：同一个工作线程同时用于生产和消费，此时<code>FullyBuffered</code>不起作用</p></li><li><p>如果你有些任务不需要合并集合，你应该用<code>ForAll</code>遍历</p><ul><li>这在一定程度上替代了<code>Stream</code>流的功能</li></ul></li><li><p><code>ForAll</code>方法会抛出聚合异常，在这样的消费者外部使用<code>try-catch</code></p></li><li><p>对于聚合异常，可以使用<code>Handle</code>方法，传入异常处理委托，这将遍历<code>InnerExceptions</code>集合，最后需要返回是否处理成功的布尔值</p></li><li><p>使用<code>WithCancellation</code>方法来使用取消令牌：当令牌取消时，所有线程将尽快退出，已经进入的迭代仍会完成</p></li><li><p>操作取消异常<code>OperationCanceledException</code>不会放到聚合异常中</p></li></ul><h2 id="PLINQ的性能考虑"><a href="#PLINQ的性能考虑" class="headerlink" title="PLINQ的性能考虑"></a>PLINQ的性能考虑</h2><p>如果迭代任务不是过于繁重，则PLINQ的性能不如LINQ；因为对于较为轻松的工作，创建、启动线程等线程相关操作耗时太长。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;ul&gt;
&lt;li&gt;集合的数据量非常庞大时，适合使用并行LINQ（PLINQ）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AsParallel&lt;/code&gt;方法：获取集合的&lt;code&gt;ParallelQuery&lt;/code&gt;对象，然后就可以像使用一般&lt;code&gt;LINQ&lt;/code&gt;一样使用&lt;</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET多线程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET多线程(6)：并行循环</title>
    <link href="https://blog.xicuodev.top/2026/01/27/dotnet-multithreading-6-parallel-loop/"/>
    <id>https://blog.xicuodev.top/2026/01/27/dotnet-multithreading-6-parallel-loop/</id>
    <published>2026-01-27T10:07:00.143Z</published>
    <updated>2026-01-27T10:18:41.771Z</updated>
    
    <content type="html"><![CDATA[<ul><li>并行循环（parallel loop）：<code>Parallel.For(int 起点含, int 终点不含, Action 循环体委托)</code></li><li>这将在不同线程中共享循环体的资源，你需要上锁实现同步访问</li><li><code>For</code>：有序集合；<code>ForEach</code>：无序集合+有序集合</li><li><code>Parallel.Invoke(委托集合)</code>：并行运行委托集合的所有方法</li><li>循环任务必须足够繁重（串行性能非常差），才适合并行循环</li></ul><h2 id="并行循环的原理"><a href="#并行循环的原理" class="headerlink" title="并行循环的原理"></a>并行循环的原理</h2><ul><li>数据分区：分治法，把集合分成特定个部分，并创建等量的线程</li><li>主要使用线程池线程</li><li>试图替开发者做出最佳决策</li><li>阻塞调用，不需要<code>Wait</code></li></ul><h2 id="并行循环的异常处理"><a href="#并行循环的异常处理" class="headerlink" title="并行循环的异常处理"></a>并行循环的异常处理</h2><ul><li>如果有任何一个线程出现异常，则所有线程不会进入下一次迭代</li><li>所有异常将组合为一个<code>AggregateException</code>抛出，在并行循环外部<code>try-catch</code></li><li>并行任务通常都会将所有线程的异常组合为一个聚合异常抛出</li><li>如果每次迭代的耗时较长，当一个线程异常时，你想要立即停止其他线程，可以使用两个参数的委托的重载，第二个参数就是并行循环的当前状态，其<code>IsExceptional</code>属性指出了是否有线程出现异常，以便快速退出本次迭代</li></ul><h2 id="并行循环的主动干预"><a href="#并行循环的主动干预" class="headerlink" title="并行循环的主动干预"></a>并行循环的主动干预</h2><ul><li>状态的<code>Stop</code>方法和<code>IsStopped</code>属性配合使用，可以主动停止各线程</li><li>状态的<code>Break</code>方法和<code>ShouldExitCurrentIteration</code>（应该退出当前迭代）、<code>LowestBreakIteration</code>（<code>Break</code>的线程中最小的迭代位置）属性配合使用，可以使整体集合完整迭代到特定位置停止：<ul><li><code>if (state.ShouldExitCurrentIteration &amp;&amp; state.LowestBreakIteration &lt; i) return;</code></li></ul></li></ul><h2 id="Break方法怎么使并行循环“完整地”迭代到特定进度？"><a href="#Break方法怎么使并行循环“完整地”迭代到特定进度？" class="headerlink" title="Break方法怎么使并行循环“完整地”迭代到特定进度？"></a><code>Break</code>方法怎么使并行循环“完整地”迭代到特定进度？</h2><ul><li>0到100遍历，分成3个线程：0-33、33-66、66-100</li><li>线程1到30、线程2到<code>60</code>、线程3到<code>90</code>时，线程2和3的状态调用<code>Break</code>，它们立即退出，此时<code>ShouldExitCurrentIteration</code>为<code>true</code>， <code>LowestBreakIteration</code>为<code>60</code></li><li>线程1的<code>i</code>&#x3D;<code>30</code>&lt;<code>LowestBreakIteration</code>，所以它继续执行直到完成</li><li>最后，整体迭代进度停留在<code>60</code></li></ul><h2 id="为什么Break时选用LowestBreakIteration？"><a href="#为什么Break时选用LowestBreakIteration？" class="headerlink" title="为什么Break时选用LowestBreakIteration？"></a>为什么<code>Break</code>时选用<code>LowestBreakIteration</code>？</h2><ul><li><code>Break</code>的线程将立即退出，这意味着该线程负责的部分永远无法迭代完成</li><li>最小的迭代位置 (<code>LowestBreakIteration</code>) 意味着负责它前面那些部分的线程没有<code>Break</code></li><li>等到这些线程完成迭代，整体迭代进度到达最小迭代位置</li><li>这是符合<code>Break</code>语义的：<code>迭代到65退出 &amp;&amp; 迭代到80退出 == 迭代到65退出</code>，<code>65</code>是最小迭代位置</li></ul><h2 id="并行循环结果-ParallelLoopResult"><a href="#并行循环结果-ParallelLoopResult" class="headerlink" title="并行循环结果 ParallelLoopResult"></a>并行循环结果 ParallelLoopResult</h2><ul><li>当你接收并行循环返回的结果时，它是阻塞的</li><li><code>IsCompleted</code>属性：是否迭代完成</li><li><code>LowestBreakIteration</code>属性：<code>Break</code>的线程中最小的迭代位置；如果是因为<code>Stop</code>或抛出异常停止迭代，则它的值为<code>null</code></li></ul><h2 id="并行循环取消"><a href="#并行循环取消" class="headerlink" title="并行循环取消"></a>并行循环取消</h2><ul><li>使用<code>ParallelOptions</code>和<code>CancellationTokenSource</code>类</li><li><code>new ParallelOptions { CancellationToken = cts.Token }</code></li><li><code>Parallel.For(0, 1000, options, 循环体委托)</code></li><li>当调用<code>token.Cancel()</code>时，<code>Parallel.For</code>抛出<code>TaskCanceledException</code></li></ul><h2 id="并行循环中的线程本地存储"><a href="#并行循环中的线程本地存储" class="headerlink" title="并行循环中的线程本地存储"></a>并行循环中的线程本地存储</h2><ul><li>线程本地存储（thread local storage）：每个线程自己内部使用的变量；分治法</li><li><code>Parallel.For(0, 100, lcoalInit, (i,state,tls)=&gt;{}, localFinally)</code><ul><li><code>localInit</code>参数：委托，初始化<code>tls</code>并返回</li><li><code>localFinally</code>参数：委托，线程完成枚举时处理<code>tls</code>，依然是线程的一部分，使用共享资源时需要加锁同步</li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;ul&gt;
&lt;li&gt;并行循环（parallel loop）：&lt;code&gt;Parallel.For(int 起点含, int 终点不含, Action</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET多线程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET多线程(5)：异步编程</title>
    <link href="https://blog.xicuodev.top/2026/01/27/dotnet-multithreading-5-asynchronous/"/>
    <id>https://blog.xicuodev.top/2026/01/27/dotnet-multithreading-5-asynchronous/</id>
    <published>2026-01-27T09:40:19.023Z</published>
    <updated>2026-01-27T10:03:48.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程-vs-异步编程"><a href="#多线程-vs-异步编程" class="headerlink" title="多线程 vs. 异步编程"></a>多线程 vs. 异步编程</h2><ul><li>多线程与异步编程二者本质上相同，只是侧重点不同</li><li>多线程侧重于分而治之的场景，异步编程侧重于卸载长时间运行的任务（详见<a href="/2026/01/25/dotnet-multithreading-1-basic/#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F" title=".NET多线程(1)：多线程基础">为什么要使用多线程</a>）</li><li>多线程适用于CPU密集型操作，异步编程适用于I&#x2F;O密集型操作</li><li>I&#x2F;O操作：访问本地文件、访问数据库、访问互联网</li></ul><h2 id="Task类"><a href="#Task类" class="headerlink" title="Task类"></a><code>Task</code>类</h2><ul><li>构造器：<code>new Task(委托)</code></li><li><code>Start</code>方法</li><li>更常见的写法：<code>var task = Task.Run(委托)</code></li><li><code>Task</code>对象中封装了许多实用数据和功能</li><li>使用<code>Task.Delay(毫秒数)</code>，而不是<code>Thread.Sleep(毫秒数)</code></li></ul><h2 id="Thread类-vs-Task类"><a href="#Thread类-vs-Task类" class="headerlink" title="Thread类 vs. Task类"></a><code>Thread</code>类 vs. <code>Task</code>类</h2><ul><li><code>Task</code>是一个承诺（<code>Promise</code>）：它不一定涉及线程，只是承诺在未来某个时间完成任务</li><li>推荐使用<code>Task</code>类而不是<code>Thread</code>类，因为<code>Task</code>类是更高级别的抽象，开箱即用，而<code>Thread</code>类更底层<ul><li>默认使用线程池；从任务中返回结果；简单的任务延续；更好异常处理</li><li><code>Async</code>&#x2F;<code>Await</code>：使编写异步代码像编写同步代码一样；便于同步上下文，解决线程亲和性问题</li></ul></li></ul><h2 id="从任务中返回结果"><a href="#从任务中返回结果" class="headerlink" title="从任务中返回结果"></a>从任务中返回结果</h2><ul><li><code>Task.Run(委托)</code>返回的<code>Task&lt;T&gt;</code>中的泛型<code>T</code>就是返回值类型</li><li><code>Result</code>属性：委托方法的返回值</li></ul><h2 id="任务阻塞-Task-Blocking"><a href="#任务阻塞-Task-Blocking" class="headerlink" title="任务阻塞 Task Blocking"></a>任务阻塞 Task Blocking</h2><ul><li><code>Wait</code>方法：阻塞调用线程，直到任务完成</li><li><code>WaitAll</code>静态方法：阻塞调用线程，直到所有任务完成</li><li><code>Result</code>属性：阻塞调用线程，直到任务完成并返回结果</li></ul><h2 id="任务延续-Task-Continuation"><a href="#任务延续-Task-Continuation" class="headerlink" title="任务延续 Task Continuation"></a>任务延续 Task Continuation</h2><ul><li><p><code>ContinueWith</code>方法：创建一个工作线程，执行传入的委托，委托提供主调<code>Task</code>对象的参数</p></li><li><p><code>WhenAll</code>静态方法：接收并返回<code>Task</code>数组，表示当所有<code>Task</code>完成时</p></li><li><p><code>WhenAny</code>静态方法：接收<code>Task</code>数组，返回<code>Task</code>，表示当任一<code>Task</code>完成时</p></li><li><p>配合<code>ContinueWith</code>或<code>await</code>使用，让<code>When</code>返回的任务实际运行起来</p></li><li><p>延续链（continuation chain）：你可以链式使用<code>ContinueWith</code>，形成一条任务链 <code>Task&lt;Task&lt;string&gt;&gt;</code></p></li><li><p>拆包装（unwrap）：但你并不想要 <code>Task&lt;Task&lt;string&gt;&gt;</code> 这种套娃的怪东西，因此需要用到<code>Unwrap</code>方法，它将执行里面的<code>Task</code>，并返回<code>Task&lt;string&gt;</code></p></li><li><p><code>Unwrap</code>也是非阻塞的，它会在工作线程中执行相关操作</p></li></ul><h2 id="任务的异常处理"><a href="#任务的异常处理" class="headerlink" title="任务的异常处理"></a>任务的异常处理</h2><ul><li><p>任务中的异常是隐藏的，不会影响主线程继续运行</p></li><li><p>对任务使用外部<code>try-catch</code>不起作用</p><ul><li>任何在委托外部的<code>try-catch</code>都是无稽之谈，因为委托一般不会就地执行</li></ul></li><li><p>异常存储在任务本身中：<code>Status</code>属性（异常时值为<code>Faulted</code>故障）和<code>Exception</code>属性（<code>System.AggregateException</code>类，存储所有异常）</p></li><li><p>可以迭代这些异常：<code>task.Exception.InnerExceptions</code>属性</p></li><li><p>使用<code>Wait</code>或<code>Result</code>：抛出任务的<code>AggregateException</code></p></li><li><p><code>ContinueWith</code>方法有个重载，第二个参数为<code>TaskContinuationOptions</code>枚举，设置为<code>NotOnFaulted</code>就会抛出<code>AggregateException</code></p></li><li><p>使用<code>await</code>：如果有任何异常，直接抛出，不再延续执行</p></li></ul><h2 id="任务同步-Task-Synchronization"><a href="#任务同步-Task-Synchronization" class="headerlink" title="任务同步 Task Synchronization"></a>任务同步 Task Synchronization</h2><ul><li>任务同步和线程同步的办法完全一样</li><li>任务同步：<code>lock</code>关键字、监视器、互斥锁和读写锁</li><li>任务交互：信号量、自动重置事件和手动重置事件</li></ul><h2 id="任务取消-Task-Cancellation"><a href="#任务取消-Task-Cancellation" class="headerlink" title="任务取消 Task Cancellation"></a>任务取消 Task Cancellation</h2><ul><li>任务取消和线程取消的办法别无二致</li><li>设置一个共享的标志变量，如 <code>bool cancelTask</code></li><li>更好的做法：<code>CancellationTokenSource</code>类（非托管资源，使用<code>using</code>）<ul><li>获取令牌：<code>Token</code>属性（<code>CancellationToken</code>类）</li><li>请求取消：<code>Cancel</code>方法</li><li>是否请求取消：<code>IsCancellationRequested</code>属性</li><li>超时取消：<code>CancelAfter</code>方法，若取消，应抛出<code>OperationCanceledException</code>；为此，推荐使用<code>ThrowIfCancellationRequested</code>方法</li><li>异步方法API通常都有个重载接收<code>CancellationToken</code>来实现取消异步操作，如<code>HttpClient</code>类<code>GetStringAsync</code>方法的第二个参数</li></ul></li></ul><h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async &amp; Await"></a>Async &amp; Await</h2><ul><li><p>使用<code>async</code>修饰异步方法，并在异步任务前加<code>await</code>，使编写异步代码看起来就像在编写同步代码</p></li><li><p>当你在主线程调用异步方法时，它将在一个工作线程中异步执行</p></li><li><p>在异步方法中，<code>await</code>之后的所有内容都是异步任务的延续</p><ul><li><code>await</code>之前的内容在主线程上执行，之后的内容在工作线程上执行</li></ul></li><li><p>当程序运行到<code>await</code>关键字时，调用线程立即被释放，它可以自由地继续运行</p></li><li><p><code>await</code>将返回任务的结果，而不是结果的任务</p></li><li><p>使用<code>async</code>和<code>await</code>会自动管理同步上下文，<code>await</code>的延续代码将在同步上下文中执行</p></li><li><p>异步方法返回结果的任务，如果方法体返回<code>int</code>，则异步方法返回<code>Task&lt;int&gt;</code>；如果方法体没有返回值，则异步方法返回<code>Task</code></p></li><li><p>如果将异步方法的返回值类型设置为<code>void</code>，将不能在后续应用<code>Task</code>特性，不能用<code>await</code>；除非你在编写程序入口方法或实现外部API方法等不需要在后续用上<code>Task</code>特性的方法，否则不推荐这么做</p></li><li><p>异步方法的命名约定：在名称后加<code>Async</code>后缀，如<code>FetchDataAsync</code></p></li></ul><h2 id="Await到底做了什么？"><a href="#Await到底做了什么？" class="headerlink" title="Await到底做了什么？"></a>Await到底做了什么？</h2><ul><li>编译器会创建一个状态机对象，并以每个<code>await</code>语句作为段落结尾，来划分状态</li><li>每个状态都会记录当前状态和变量集合，并捕获同步上下文</li><li>每完成一个状态，它会调用<code>moveNext</code>方法，在捕获到的同步上下文中执行下一个状态</li><li>通过状态集合执行包含多个<code>await</code>的异步方法</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;多线程-vs-异步编程&quot;&gt;&lt;a href=&quot;#多线程-vs-异步编程&quot; class=&quot;headerlink&quot; title=&quot;多线程 vs. 异步编程&quot;&gt;&lt;/a&gt;多线程 vs.</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET多线程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET多线程(4)：线程安全</title>
    <link href="https://blog.xicuodev.top/2026/01/26/dotnet-multithreading-4-safety/"/>
    <id>https://blog.xicuodev.top/2026/01/26/dotnet-multithreading-4-safety/</id>
    <published>2026-01-26T04:08:04.397Z</published>
    <updated>2026-01-26T04:47:02.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程亲和性-Thread-Affinity"><a href="#线程亲和性-Thread-Affinity" class="headerlink" title="线程亲和性 Thread Affinity"></a>线程亲和性 Thread Affinity</h2><ul><li>在工作线程中访问主线程中的资源时，需要同步上下文</li><li>主线程中的资源一般会提供<code>Invoke</code>方法</li><li><code>Invoke</code>方法：传递委托，委托的方法体上下文就是同步上下文</li><li><code>InvokeRequired</code>属性：是否需要调用<code>Invoke</code>方法；如果方法是在主线程调用，那么就不能用<code>Invoke</code>方法</li></ul><h2 id="线程安全-Thread-Safety"><a href="#线程安全-Thread-Safety" class="headerlink" title="线程安全 Thread Safety"></a>线程安全 Thread Safety</h2><p>当一个函数、数据结构或类可以被多个线程并发使用，而不会产生竞态条件、不一致行为或数据损坏时，它就是线程安全的。</p><ul><li>线程安全的语法实体内部已经使用了适当的同步机制，使用它们时不需要另外采取线程同步措施。</li></ul><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>线程的生命周期开始于 <code>System.Threading.Thread</code>类的实例被创建时，结束于线程被终止或执行完成时。</p><ul><li>未启动状态：当线程实例被创建，但<code>Start</code>方法未被调用时</li><li>就绪状态：当线程准备好运行，并等待CPU周期时</li><li>不可运行状态：调用了<code>Sleep</code>方法；调用了<code>Wait</code>方法；通过I&#x2F;O操作阻塞</li><li>死亡状态：当线程已经执行完毕，或已经终止时</li></ul><h2 id="让线程等待一段时间"><a href="#让线程等待一段时间" class="headerlink" title="让线程等待一段时间"></a>让线程等待一段时间</h2><ul><li><code>Thread.Sleep(毫秒数)</code>：线程将被调度器踢出CPU，为不可运行状态，即<code>WaitSleepJoin</code>状态</li><li><code>Thread.SpinWait(次数)</code>：相当于<code>for</code>循环，线程会被保持在CPU内，只是繁忙等待；但如果占用CPU时间太长，超过分配时间片，仍会被调度器踢出</li><li><code>SpinWait.SpinUntil(条件,超时毫秒数)</code>：繁忙等待，直到满足条件或超时</li><li>后两种方法谨慎使用，小心耗尽CPU资源</li></ul><h2 id="从线程中返回结果"><a href="#从线程中返回结果" class="headerlink" title="从线程中返回结果"></a>从线程中返回结果</h2><ul><li><code>Thread</code>类没有内置的方法返回结果，更好的选择是<code>Task</code>类</li><li><code>Thread</code>类返回结果的唯一方式是共享变量</li></ul><h2 id="线程取消-Thread-Cancellation"><a href="#线程取消-Thread-Cancellation" class="headerlink" title="线程取消 Thread Cancellation"></a>线程取消 Thread Cancellation</h2><ul><li>设置一个共享的标志变量，如 bool cancelThread</li><li>更好的做法：CancellationTokenSource类，详见任务取消</li></ul><h2 id="线程池-Thread-Pool"><a href="#线程池-Thread-Pool" class="headerlink" title="线程池 Thread Pool"></a>线程池 Thread Pool</h2><ul><li>创建和释放线程需要时间和空间，每次都创建新的性能很差</li><li>每个应用程序都有一个线程池，并定义了最大和最小线程数</li></ul><p>线程池的行为：</p><ul><li>达到最小值之前，每次都创建新线程</li><li>达到最小值之后，每次用空闲的，只有都繁忙，才创建新线程</li><li>达到最大值之后，如果都繁忙，只能排队等待空闲线程</li></ul><h2 id="工作线程的异常处理"><a href="#工作线程的异常处理" class="headerlink" title="工作线程的异常处理"></a>工作线程的异常处理</h2><ul><li>每个线程都有自己的调用堆栈，工作线程抛出的异常永远不会到达主线程</li><li>简单的做法是在工作线程内使用<code>try-catch</code>块，并自行处理</li><li>更好的做法是使用共享资源，创建一个异常列表 <code>List&lt;Exception&gt;</code>，在工作线程中<code>catch</code>异常并将其加入列表，并在主线程统一处理</li><li>更更好的做法是使用<code>Task</code>类，它有内置的异常处理机制</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;线程亲和性-Thread-Affinity&quot;&gt;&lt;a href=&quot;#线程亲和性-Thread-Affinity&quot; class=&quot;headerlink&quot; title=&quot;线程亲和性 Thread Affinity&quot;&gt;&lt;/a&gt;线程亲和性 Thread</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET多线程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET多线程(3)：线程交互</title>
    <link href="https://blog.xicuodev.top/2026/01/26/dotnet-multithreading-3-interaction/"/>
    <id>https://blog.xicuodev.top/2026/01/26/dotnet-multithreading-3-interaction/</id>
    <published>2026-01-26T03:51:03.808Z</published>
    <updated>2026-01-26T04:07:56.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 <code>Semaphore</code></h2><ul><li>信号量主要用于控制并发线程或进程（指定名称）的个数，一般不用于保护临界区</li><li><code>SemaphoreSlim</code>类（<code>Semaphore</code>类的精简版，没有跨进程功能，后者有）<ul><li>参数：<code>initialCount</code>：初始个数；<code>maxCount</code>：最大个数；倒计数，每次获取时减1</li></ul></li><li><code>Wait</code>方法：获取一个信号量，如果信号量不足，则阻塞</li><li><code>Release</code>方法：释放一个信号量</li><li><code>Wait</code>和<code>Release</code>不必在同一线程中（信号量不具有线程亲和性）</li><li><code>SemaphoreSlim</code>对象使用非托管资源，使用<code>using</code>避免内存泄漏</li><li>在Web服务器示例中，在请求队列的监控线程获取信号量，并在请求处理线程释放信号量，实现有限个监控线程并发（这里信号量不用于保护临界区，因此别忘了给入队出队的逻辑加写锁）</li></ul><h2 id="自动重置事件-AutoResetEvent"><a href="#自动重置事件-AutoResetEvent" class="headerlink" title="自动重置事件 AutoResetEvent"></a>自动重置事件 <code>AutoResetEvent</code></h2><ul><li>自动重置事件用于信号传递（Signaling）</li><li>典型应用：生产者-消费者场景<ul><li>生产者线程生产了足够资源时，向消费者线程传递布尔类型信号</li><li>如果生产者足够快，消费者线程就能并发</li><li>但如果生产者过于快，就会造成资源浪费，为此你需要把产品放入队列中</li></ul></li><li>构造器参数：<code>bool initialState</code>：初始状态，如果初始时已经有资源，可以设为<code>true</code></li><li><code>WaitOne</code>方法：等待信号，阻塞</li><li><code>Set</code>方法：设置信号</li><li><code>AutoResetEvent</code>对象使用非托管资源，使用<code>using</code>避免内存泄漏</li></ul><h2 id="手动重置事件-ManualResetEvent"><a href="#手动重置事件-ManualResetEvent" class="headerlink" title="手动重置事件 ManualResetEvent"></a>手动重置事件 <code>ManualResetEvent</code></h2><ul><li>在自动重置事件中，一旦有线程持有信号，信号将自动重置；而在手动重置事件中，你需要调用<code>Reset</code>方法手动重置信号</li><li>典型应用：在分治法中，每次都需要多个工作线程并发运行</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;信号量-Semaphore&quot;&gt;&lt;a href=&quot;#信号量-Semaphore&quot; class=&quot;headerlink&quot; title=&quot;信号量 Semaphore&quot;&gt;&lt;/a&gt;信号量</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET多线程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET多线程(2)：线程同步</title>
    <link href="https://blog.xicuodev.top/2026/01/25/dotnet-multithreading-2-synchronization/"/>
    <id>https://blog.xicuodev.top/2026/01/25/dotnet-multithreading-2-synchronization/</id>
    <published>2026-01-25T11:41:53.932Z</published>
    <updated>2026-01-25T12:53:28.880Z</updated>
    
    <content type="html"><![CDATA[<ul><li>共享资源：并发的线程竞争共享资源，造成冲突和资源争抢</li></ul><p>非原子操作与原子操作：</p><ul><li>非原子操作：可以拆分的操作，如 <code>count++</code> 实则为先 <code>temp+1</code> 再赋值给 <code>count</code>，缓存天然缺乏时效性，造成不一致行为和竞态条件</li><li>原子操作：不可拆分的操作，调度器不能中断它而去执行其他线程</li></ul><p>临界区与线程同步：</p><ul><li>临界区 (critical section)：线程中访问共享资源的操作区域，它应该是原子的</li><li>线程同步 (thread synchronization)：解决资源争抢的问题，你方唱罢我登场（舞台是共享的）</li></ul><h2 id="非原子操作为什么导致不一致行为？"><a href="#非原子操作为什么导致不一致行为？" class="headerlink" title="非原子操作为什么导致不一致行为？"></a>非原子操作为什么导致不一致行为？</h2><ol><li>你缓存A的值，还未加1，分配给你的时间片就到了，于是调度器将你挂起，让我执行</li><li>我给A加了1，调度器再让你执行，这时你的缓存已经丢失了时效性，你现在是给过去的A加1，再赋值给现在的A，污染了现在的A</li></ol><h2 id="两种常见的锁机制：写锁和读锁"><a href="#两种常见的锁机制：写锁和读锁" class="headerlink" title="两种常见的锁机制：写锁和读锁"></a>两种常见的锁机制：写锁和读锁</h2><ul><li>排它锁&#x2F;写锁&#x2F;X锁 (Exclusive Lock)：当一个线程持有写锁时，其他线程既不能获取写锁，也不能获取读锁</li><li>共享锁&#x2F;读锁&#x2F;S锁 (Shared Lock)：当一个线程持有读锁时，其他线程不能获取写锁，只能获取读锁</li></ul><p>如果一个线程不能获取它想要的锁，它将阻塞并等待该锁释放；例如：线程获取读锁时，如果有其他线程持有写锁，则阻塞</p><h2 id="NET线程同步的4个实现"><a href="#NET线程同步的4个实现" class="headerlink" title=".NET线程同步的4个实现"></a>.NET线程同步的4个实现</h2><h3 id="lock关键字（写锁）"><a href="#lock关键字（写锁）" class="headerlink" title="lock关键字（写锁）"></a><code>lock</code>关键字（写锁）</h3><p><code>lock(锁对象) { 锁主体(通常是临界区) }</code></p><p>锁主体同时只能由一个线程执行，即持有锁对象的线程；锁主体表现的就像是原子操作</p><ul><li>在 .NET 8&#x2F;C# 12（含）以前，使用一个<code>object</code>对象当作锁对象即可</li><li>在 .NET 9&#x2F;C# 13（含）以后，有专门的<code>System.Threading.Lock</code>对象</li></ul><p>锁主体中隐含<code>try-finally</code>机制，在<code>finally</code>中会释放锁对象，因此不必担心锁主体抛出异常，导致锁对象无法释放</p><h3 id="监视器-Monitor（写锁）"><a href="#监视器-Monitor（写锁）" class="headerlink" title="监视器 Monitor（写锁）"></a>监视器 <code>Monitor</code>（写锁）</h3><ul><li>监视器：监视临界区，如果有一个线程进入临界区，就让其他线程阻塞等待<ul><li><code>lock</code>关键字是监视器的语法糖，因此监视器可以提供比<code>lock</code>更细粒度的控制</li></ul></li><li><code>Monitor.Enter(锁对象)</code>：进入临界区，如果锁对象已经被持有，就阻塞等待（如果锁一直得不到释放，会导致无限等待）</li><li><code>Monitor.Exit(锁对象)</code>：退出临界区，释放锁对象<ul><li>使用<code>try-finally</code>机制，在<code>finally</code>中调用<code>Exit</code>方法，以确保始终释放锁对象（监视器需要手动释放锁对象）</li></ul></li><li><code>Monitor.TryEnter(锁对象,等待时间)</code> ：如果锁对象被持有，就先等待一段时间；如果时间到了锁还是没有释放，就返回<code>false</code>，你可据此设计请求超时的分支逻辑；否则返回<code>true</code>（不会导致无限等待，或长时间等待，这会让用户无所适从，对用户不友好）</li></ul><h3 id="互斥锁-Mutex（写锁）"><a href="#互斥锁-Mutex（写锁）" class="headerlink" title="互斥锁 Mutex（写锁）"></a>互斥锁 <code>Mutex</code>（写锁）</h3><ul><li>互斥锁是写锁的一种跨进程实现，而监视器只能在同一进程内使用</li><li>互斥锁在操作系统中使用，因此需要保证其名称进程间唯一<ul><li>创建互斥锁比创建监视器需要更多资源，除非你需要跨进程同步，否则不应使用互斥锁</li></ul></li><li>互斥锁构造器：<code>new Mutex(false, &quot;GlobalMutex&quot;)</code><ul><li>参数1：初始所有权</li><li>参数2：互斥锁名称，只有命了名的互斥锁才能跨进程共享</li></ul></li><li><code>Mutex</code>对象使用非托管资源（不由编译器托管），需要程序自行释放；创建对象时，使用<code>using</code>关键字让编译器帮你在合适的时机释放它：<code>using var mutex = new Mutex()</code></li><li><code>WaitOne</code>方法：阻塞等待以获取该互斥锁</li><li><code>ReleaseMutex</code>方法：释放该互斥锁（这不是从内存释放<code>Mutex</code>对象！）</li></ul><h3 id="读写锁-ReaderWriterLock（写锁-读锁）"><a href="#读写锁-ReaderWriterLock（写锁-读锁）" class="headerlink" title="读写锁 ReaderWriterLock（写锁&amp;读锁）"></a>读写锁 <code>ReaderWriterLock</code>（写锁&amp;读锁）</h3><ul><li><code>ReaderWriterLockSlim</code>类（<code>ReaderWriterLock</code>类的精简改进版）<ul><li>获取&#x2F;释放写锁：<code>(Try)EnterWriteLock</code>和<code>ExitWriteLock</code>方法</li><li>获取&#x2F;释放读锁：<code>(Try)EnterReadLock</code>和<code>ExitReadLock</code>方法</li></ul></li><li><code>ReaderWriterLockSlim</code>对象使用非托管资源，使用<code>using</code>避免内存泄漏</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;ul&gt;
&lt;li&gt;共享资源：并发的线程竞争共享资源，造成冲突和资源争抢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非原子操作与原子操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非原子操作：可以拆分的操作，如 &lt;code&gt;count++&lt;/code&gt; 实则为先 &lt;code&gt;temp+1&lt;/code&gt;</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET多线程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET多线程(1)：多线程基础</title>
    <link href="https://blog.xicuodev.top/2026/01/25/dotnet-multithreading-1-basic/"/>
    <id>https://blog.xicuodev.top/2026/01/25/dotnet-multithreading-1-basic/</id>
    <published>2026-01-25T11:37:20.835Z</published>
    <updated>2026-01-25T11:45:47.927Z</updated>
    
    <content type="html"><![CDATA[<p>这几篇.NET多线程笔记写于2025年11月底-12月初。</p><h2 id="进程、线程与线程调度器"><a href="#进程、线程与线程调度器" class="headerlink" title="进程、线程与线程调度器"></a>进程、线程与线程调度器</h2><ul><li>进程 (process)：一个应用程序包含一个或多个进程，每个进程包含一个或多个线程</li><li>线程 (thread)：线程是CPU工作的基本单位，CPU只能看到一个个线程</li><li>线程调度器 (thread scheduler)：一块CPU核心同一时刻只能执行一条线程，因此需要调度器管理线程的执行<ul><li>线程调度器是操作系统的一部分，应用程序开发者不可控制</li></ul></li><li>时间片：由操作系统分配的每个线程一次占据CPU的时间，每轮每条线程的时间片执行完后重新分配</li></ul><p>主线程与工作线程：</p><ul><li>主线程：每个应用进程至少有一个主线程</li><li>工作线程：应用进程中主线程之外的其他线程</li></ul><p>单线程进程与多线程进程：</p><ul><li>单线程进程：只有一个主线程的进程</li><li>多线程进程：拥有一个主线程和多个工作线程的进程</li></ul><h2 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h2><ul><li>并发：对于多核的CPU，同一时刻会有多条线程在不同的CPU核心上并发地执行<ul><li>单核CPU没有真正的并发，它的多任务场景只是极快速地交替执行多个线程</li></ul></li><li>多线程实现“分而治之” (divide and conquer)：把数组的累加工作分成多份，交给不同的线程完成</li><li>阻塞：使用<code>Join</code>方法，让被调线程阻塞主调线程，直到阻塞队列执行完毕，主调线程才能继续执行</li><li>用工作线程卸载 (offload) 长时间运行的任务：否则它将阻塞主线程（在GUI应用中就是UI线程，从而导致UI长时间未响应，对用户不友好）</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;这几篇.NET多线程笔记写于2025年11月底-12月初。&lt;/p&gt;
&lt;h2 id=&quot;进程、线程与线程调度器&quot;&gt;&lt;a href=&quot;#进程、线程与线程调度器&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET多线程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET日志(5)：监控与告警</title>
    <link href="https://blog.xicuodev.top/2025/12/18/dotnet-logging-5-monitoring-and-alerting/"/>
    <id>https://blog.xicuodev.top/2025/12/18/dotnet-logging-5-monitoring-and-alerting/</id>
    <published>2025-12-18T09:54:11.788Z</published>
    <updated>2026-01-25T11:45:51.979Z</updated>
    
    <content type="html"><![CDATA[<p>监控涉及系统中的事件或指标，并基于这些数据采取行动，主要目的是为了及时发现并告警系统异常、性能瓶颈或业务逻辑问题。任何停机、任何严重错误、任何95%的性能下降等问题，都能基于基于推送至某一平台的日志非常容易地检测到，每个具备一定监控能力的平台都会有自己的<strong>告警系统</strong>。</p><p>在Application Insights中，监视器（Monitor）-告警（Alerts）允许用户基于日志数据创建监控规则，并在满足特定条件时触发告警通知。告警规则可以基于各种指标和日志查询来定义，例如响应时间、错误率、请求数量等。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/2025/12/18/dotnet-logging-5-monitoring-and-alerting/ApplicationInsights%E5%91%8A%E8%AD%A6.webp"                                     ></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;监控涉及系统中的事件或指标，并基于这些数据采取行动，主要目的是为了及时发现并告警系统异常、性能瓶颈或业务逻辑问题。任何停机、任何严重错误、任何95%的性能下降等问题，都能基于基于推送至某一平台的日志非常容易地检测到，每个具备一定监控能力的平台都会有自己的&lt;strong&gt;告警</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET日志" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET日志(4)：性能优化</title>
    <link href="https://blog.xicuodev.top/2025/12/17/dotnet-logging-4-performance/"/>
    <id>https://blog.xicuodev.top/2025/12/17/dotnet-logging-4-performance/</id>
    <published>2025-12-17T02:58:20.929Z</published>
    <updated>2026-01-25T11:45:59.292Z</updated>
    
    <content type="html"><![CDATA[<p>日志是一个<strong>切面关注点</strong>，日志的记录会影响整个系统的性能。在程序的<strong>热点路径</strong>上，日志记录的开销可能会显著影响应用程序的响应时间和吞吐量，这些日志必须非常轻量、非常高效。</p><p>使用日志消息模板字符串时，为了结构化日志，每记录一条日志，日志记录器都需要创建这些参数的数组，并对参数装箱（因为是<code>object[]</code>数组）。日志一多，会造成大量内存开销。要优化它，可以使用<code>LoggerMessage.Define</code>方法来预定义日志消息模板，从而避免在每次记录日志时的装箱和数组分配。</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Action&lt;ILogger, <span class="built_in">int</span>, Exception?&gt; _logUserLoggedIn =</span><br><span class="line">    LoggerMessage.Define&lt;<span class="built_in">int</span>&gt;(LogLevel.Information,</span><br><span class="line">      <span class="keyword">new</span> EventId(<span class="number">1</span>, <span class="keyword">nameof</span>(UserLoggedIn)),</span><br><span class="line">      <span class="string">&quot;User &#123;UserId&#125; has logged in.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UserLoggedIn</span>(<span class="params"><span class="built_in">int</span> userId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 一些业务代码 */</span></span><br><span class="line">  _logUserLoggedIn(_logger, userId, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><code>Action</code>委托使用泛型以<strong>强类型参数</strong>传入（如 <code>int</code>），减少装箱并更易被JIT优化&#x2F;内联。</li><li><code>Define</code>方法内部会对每种不同参数个数的消息模板使用特定<strong>格式化器</strong>，避免了数组分配。</li><li><code>&quot;User {UserId} has logged in.&quot;</code>是一个编译时常量，会在内存中驻留（interned）。</li></ul><p>这种写法比较繁琐，要解决这个问题，使用<strong>Source Generator</strong>（源代码生成器，由<code>Microsoft.Extensions.Logging.Generators</code>提供）在编译时生成代码，你只需使用<code>LoggerMessage</code>注解声明<code>ILogger</code>的扩展方法：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">LoggerExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">LoggerMessage(EventId = 1, Level = LogLevel.Information, Message = <span class="string">&quot;User &#123;UserId&#125; has logged in.&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">LogUserLoggedIn</span>(<span class="params"><span class="keyword">this</span> ILogger logger, <span class="built_in">int</span> userId</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过阅读<code>LoggerMessage</code>注解，Source Generator会生成类似上面使用<code>LoggerMessage.Define</code>的代码，从而实现性能优化，同时让开发体验更好。</p><p>使用时，可以直接调用<code>LogUserLoggedIn</code>扩展方法：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UserLoggedIn</span>(<span class="params"><span class="built_in">int</span> userId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 一些业务代码 */</span></span><br><span class="line">  _logger.LogUserLoggedIn(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;日志是一个&lt;strong&gt;切面关注点&lt;/strong&gt;，日志的记录会影响整个系统的性能。在程序的&lt;strong&gt;热点路径&lt;/strong&gt;上，日志记录的开销可能会显著影响应用程序的响应时间和吞吐量，这些日志必须非常轻量、非常高效。&lt;/p&gt;
&lt;p&gt;使用日志消息模板字符串时，为</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET日志" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET日志(3)：Serilog</title>
    <link href="https://blog.xicuodev.top/2025/12/13/dotnet-logging-3-serilog/"/>
    <id>https://blog.xicuodev.top/2025/12/13/dotnet-logging-3-serilog/</id>
    <published>2025-12-13T02:00:00.000Z</published>
    <updated>2026-01-25T11:46:07.082Z</updated>
    
    <content type="html"><![CDATA[<p>无论是作用域、<code>IsEnabled</code>、格式化或消息模板的概念，还是结构化日志记录，<code>Serilog</code>都是这些功能的开创者和标准化者。</p><ul><li>对消息模板、结构化日志、参数解析等都有极佳的支持。</li><li>庞大的Sinks家族：<code>Serilog</code>的<code>Sinks</code>就相当于<code>Logging</code>中的<code>Provider</code>，而<code>Serilog</code>的<code>Sinks</code>可能有几十个甚至上百个。</li></ul><h2 id="创建Serilog日志记录器"><a href="#创建Serilog日志记录器" class="headerlink" title="创建Serilog日志记录器"></a>创建Serilog日志记录器</h2><ul><li>引入<code>Serilog</code>包</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration().CreateLogger();</span><br></pre></td></tr></table></figure></div><h2 id="配置Serilog日志接收器-Sinks"><a href="#配置Serilog日志接收器-Sinks" class="headerlink" title="配置Serilog日志接收器 Sinks"></a>配置Serilog日志接收器 Sinks</h2><ul><li>想要什么接收器，就引入什么<code>Serilog.Sinks.SomeSink</code>包</li><li><code>LoggerConfiguration.WirteTo</code>属性：<code>Sinks</code>扩展该属性以配置它自己，通常是<code>SomeSinks</code>扩展方法</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration()  </span><br><span class="line">    .WriteTo.Console(theme: AnsiConsoleTheme.Code)  </span><br><span class="line">    .CreateLogger();</span><br></pre></td></tr></table></figure></div><ul><li><code>Serilog.Sinks.Console</code>包：<ul><li><code>Console</code>扩展方法：<ul><li><code>theme</code>参数：自定义控制台日志的配色方案</li></ul></li></ul></li><li><code>Serilog.Sinks.File</code>包：<ul><li><code>File</code>扩展方法：<ul><li><code>path</code>参数</li><li><code>rollingInterval</code>参数：滚动间隔，<code>RollingInterval</code>枚举，按多久划分日志文件</li><li><code>rollOnFileSizeLimit</code>参数：文件太大时是否使用新文件</li></ul></li></ul></li></ul><h2 id="静态Serilog日志记录器"><a href="#静态Serilog日志记录器" class="headerlink" title="静态Serilog日志记录器"></a>静态Serilog日志记录器</h2><p>你可以为<code>Log</code>类的<code>Logger</code>属性注册一个日志记录器，它将成为全局可用的静态记录器。</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log.Logger = logger;</span><br></pre></td></tr></table></figure></div><p>当你使用多个提供程序时，其中许多提供程序会在内存中缓冲日志，要把缓存实际刷新到每个提供程序，你可以执行<code>Log.CloseAndFlush()</code>或<code>Log.CloseAndFlushAsync()</code>以提高效率，避免频繁调用。</p><h2 id="将Serilog集成到ASP-NET-Core应用程序"><a href="#将Serilog集成到ASP-NET-Core应用程序" class="headerlink" title="将Serilog集成到ASP.NET Core应用程序"></a>将Serilog集成到ASP.NET Core应用程序</h2><p>将<code>Serilog</code>集成为内置日志记录器的一个提供程序，从而有效“接管”内置日志记录器。</p><ul><li>引入<code>Serilog.AspNetCore</code>包</li><li>在<code>builder.Host</code>属性上调用<code>UseSerilog</code>扩展方法：</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.Host.UseSerilog();</span><br></pre></td></tr></table></figure></div><p>你可以通过设置静态<code>Serilog</code>日志记录器来配置<code>Serilog</code>日志记录器。</p><h2 id="将Serilog集成到非主机应用程序"><a href="#将Serilog集成到非主机应用程序" class="headerlink" title="将Serilog集成到非主机应用程序"></a>将Serilog集成到非主机应用程序</h2><p>例如 Avalonia 桌面应用程序，直接使用 <code>Log.Logger = new LoggerConfiguration()</code> 初始化，在应用启动早期（Avalonia 的 <code>App.OnFrameworkInitializationCompleted</code> 之前或之内）完成配置，应用退出时显式调用 <code>Log.CloseAndFlush()</code>。</p><h2 id="用配置文件配置Serilog"><a href="#用配置文件配置Serilog" class="headerlink" title="用配置文件配置Serilog"></a>用配置文件配置Serilog</h2><p>在 <code>appsettings.json</code> 中配置Serilog：</p><div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Serilog&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;MinimumLevel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Override&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Microsoft.AspNetCore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Warning&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;WriteTo&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Console&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><p>由于已经在配置文件中完成了所有配置，你不需要在代码中硬编码任何配置，只需要导入配置文件：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Log.Logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">.ReadFrom.Configuration(builder.Configuration)</span><br><span class="line">.CreateLogger();</span><br></pre></td></tr></table></figure></div><ul><li><code>builder.Configuration</code>是ASP.NET Core应用程序的配置对象，通常包含<code>appsettings.json</code>文件</li></ul><h2 id="Serilog日志功能增强"><a href="#Serilog日志功能增强" class="headerlink" title="Serilog日志功能增强"></a>Serilog日志功能增强</h2><p><code>Serilog.Enrichers</code>包提供了许多丰富的功能增强，可以为日志事件添加更多上下文信息。</p><ul><li><code>Serilog.Enrichers.Environment</code>包：添加环境信息</li><li><code>Serilog.Enrichers.Thread</code>包：添加线程信息</li><li><code>Serilog.Enrichers.Process</code>包：添加进程信息</li></ul><p>除此之外，你还可以通过<code>Properties</code>属性添加自定义属性。</p><ul><li>这里使用Json格式化器，以便你能够清晰地看到这些增强的属性。</li></ul><div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Serilog&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;MinimumLevel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Override&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Microsoft.AspNetCore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Warning&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;WriteTo&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Console&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;formatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Serilog.Formatting.Json.JsonFormatter, Serilog&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Enrich&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;FromLogContext&quot;</span><span class="punctuation">,</span> <span class="string">&quot;WithMachineName&quot;</span><span class="punctuation">,</span> <span class="string">&quot;WithThreadId&quot;</span><span class="punctuation">,</span> <span class="string">&quot;WithProcessId&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Application&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LoggingDemo&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Environment&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Development&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><ul><li>“<code>FromLogContext</code>“来自日志上下文，”<code>WithMachineName</code>“机器名，”<code>WithThreadId</code>“线程ID，”<code>WithProcessId</code>“进程ID</li></ul><div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;Timestamp&quot;</span><span class="punctuation">:</span><span class="string">&quot;2025-12-15T23:14:09.1705380+08:00&quot;</span><span class="punctuation">,</span><span class="attr">&quot;Level&quot;</span><span class="punctuation">:</span><span class="string">&quot;Information&quot;</span><span class="punctuation">,</span><span class="attr">&quot;MessageTemplate&quot;</span><span class="punctuation">:</span><span class="string">&quot;Now listening on: &#123;address&#125;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;Properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://localhost:5050&quot;</span><span class="punctuation">,</span><span class="attr">&quot;EventId&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span><span class="number">14</span><span class="punctuation">,</span><span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;ListeningOnAddress&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;SourceContext&quot;</span><span class="punctuation">:</span><span class="string">&quot;Microsoft.Hosting.Lifetime&quot;</span><span class="punctuation">,</span><span class="attr">&quot;MachineName&quot;</span><span class="punctuation">:</span><span class="string">&quot;RORMac&quot;</span><span class="punctuation">,</span><span class="attr">&quot;ThreadId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;ProcessId&quot;</span><span class="punctuation">:</span><span class="number">76483</span><span class="punctuation">,</span><span class="attr">&quot;Application&quot;</span><span class="punctuation">:</span><span class="string">&quot;LoggingDemo&quot;</span><span class="punctuation">,</span><span class="attr">&quot;Environment&quot;</span><span class="punctuation">:</span><span class="string">&quot;Development&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><h2 id="用配置文件配置Serilog-Sinks-ApplicationInsights"><a href="#用配置文件配置Serilog-Sinks-ApplicationInsights" class="headerlink" title="用配置文件配置Serilog.Sinks.ApplicationInsights"></a>用配置文件配置<code>Serilog.Sinks.ApplicationInsights</code></h2><div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Serilog&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;MinimumLevel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Override&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Microsoft.AspNetCore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Warning&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;WriteTo&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ApplicationInsights&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;connectionString&quot;</span><span class="punctuation">:</span> <span class="string">&quot;your_connection_string&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;telemetryConverter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Serilog.Sinks.ApplicationInsights.Sinks.ApplicationInsights.TelemetryConverters.TraceTelemetryConverter, Serilog.Sinks.ApplicationInsights&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><p><code>telemetryConverter</code>参数指定了使用<code>TraceTelemetryConverter</code>，将日志作为跟踪数据发送到Application Insights。</p><h2 id="Serilog结构化日志"><a href="#Serilog结构化日志" class="headerlink" title="Serilog结构化日志"></a>Serilog结构化日志</h2><p>在日志消息模板字符串的占位符的开头使用<code>@</code>符号，Serilog可以将对象序列化为结构化数据：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.Information(<span class="string">&quot;User details: &#123;@User&#125;&quot;</span>, user);</span><br></pre></td></tr></table></figure></div><p>对于实现类似JS对象行为的字典<code>Dictionary&lt;string, object&gt;</code>，Serilog能理解这是一个字典，即使不加<code>@</code>符号也会将其展开为序列化结果：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#123; <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Alice&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;Age&quot;</span>, <span class="number">30</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;IsAdmin&quot;</span>, <span class="literal">true</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">logger.Information(<span class="string">&quot;User details: &#123;User&#125;&quot;</span>, dict);</span><br></pre></td></tr></table></figure></div><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[09:18:45 INF] User details: &#123;&quot;Name&quot;: &quot;Alice&quot;, &quot;Age&quot;: 30, &quot;IsAdmin&quot;: true&#125;</span><br></pre></td></tr></table></figure></div><p>如果你希望将字典作为单个对象记录，而不是展开为多个属性，可以使用<code>$</code>符号：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.Information(<span class="string">&quot;User details: &#123;$User&#125;&quot;</span>, dict);</span><br></pre></td></tr></table></figure></div><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[09:20:12 INF] User details: System.Collections.Generic.Dictionary`2[System.String,System.Object]</span><br></pre></td></tr></table></figure></div><p>尽管这是更小众的用法，但你应该知道你有这种能力，且它在某些情况下可能会有用。</p><h2 id="Serilog转换结构化数据"><a href="#Serilog转换结构化数据" class="headerlink" title="Serilog转换结构化数据"></a>Serilog转换结构化数据</h2><p>如果你只想记录某个类型的某些特定字段，可以创建一个自定义转换器：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">.Destructure.ByTransforming&lt;Person&gt;(p =&gt; <span class="keyword">new</span> &#123; p.Name, p.Age &#125;)</span><br><span class="line">.CreateLogger();</span><br></pre></td></tr></table></figure></div><h2 id="Serilog添加自定义属性到日志上下文"><a href="#Serilog添加自定义属性到日志上下文" class="headerlink" title="Serilog添加自定义属性到日志上下文"></a>Serilog添加自定义属性到日志上下文</h2><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (LogContext.PushProperty(<span class="string">&quot;UserId&quot;</span>, userId))</span><br><span class="line">&#123;</span><br><span class="line">logger.Information(<span class="string">&quot;User logged in.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;Timestamp&quot;</span><span class="punctuation">:</span><span class="string">&quot;2025-12-15T23:30:00.1234567+08:00&quot;</span><span class="punctuation">,</span><span class="attr">&quot;Level&quot;</span><span class="punctuation">:</span><span class="string">&quot;Information&quot;</span><span class="punctuation">,</span><span class="attr">&quot;MessageTemplate&quot;</span><span class="punctuation">:</span><span class="string">&quot;User logged in.&quot;</span><span class="punctuation">,</span><span class="attr">&quot;Properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">42</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><h2 id="Serilog记录操作耗时"><a href="#Serilog记录操作耗时" class="headerlink" title="Serilog记录操作耗时"></a>Serilog记录操作耗时</h2><ul><li>引入<code>SerilogTimings</code>包</li><li>使用<code>TimeOperation</code>扩展方法记录操作耗时：</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (logger.TimeOperation(<span class="string">&quot;Processing order &#123;OrderId&#125;&quot;</span>, orderId))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 模拟处理订单的操作</span></span><br><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">500</span>);</span><br><span class="line">logger.Information(<span class="string">&quot;Order &#123;OrderId&#125; processed.&quot;</span>, orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>你还可以控制操作成功或失败时的不同行为：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> operation = logger.TimeOperation(<span class="string">&quot;Processing order &#123;OrderId&#125;&quot;</span>, orderId);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">500</span>);</span><br><span class="line"><span class="comment">/* 这是一段可能会抛出异常的业务代码 */</span></span><br><span class="line"><span class="keyword">if</span> (timeout)</span><br><span class="line">&#123;</span><br><span class="line">operation.Abandon(); <span class="comment">// 标记操作放弃</span></span><br><span class="line">logger.Warning(<span class="string">&quot;Order &#123;OrderId&#125; processing timed out.&quot;</span>, orderId);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">operation.Complete(); <span class="comment">// 标记操作成功</span></span><br><span class="line">logger.Information(<span class="string">&quot;Order &#123;OrderId&#125; processed.&quot;</span>, orderId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">operation.Fail(ex); <span class="comment">// 标记操作失败</span></span><br><span class="line">logger.Error(ex, <span class="string">&quot;Failed to process order &#123;OrderId&#125;.&quot;</span>, orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="Serilog屏蔽敏感数据"><a href="#Serilog屏蔽敏感数据" class="headerlink" title="Serilog屏蔽敏感数据"></a>Serilog屏蔽敏感数据</h2><ul><li>引入<code>Destructurama.Attributed</code>包</li><li>在<code>LoggerConfiguration.Destructure</code>属性上调用<code>UsingAttributes</code>方法：</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">.Destructure.UsingAttributes()</span><br><span class="line">.CreateLogger();</span><br></pre></td></tr></table></figure></div><ul><li>在需要屏蔽的属性上使用<code>[LogMasked]</code>注解：</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">[<span class="meta">LogMasked(Text = <span class="string">&quot;_MASKED_&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Email &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这样在日志中记录<code>User</code>对象时，<code>Email</code>属性将被屏蔽：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[09:45:00 INF] User details: &#123;&quot;Name&quot;: &quot;Alice&quot;, &quot;Email&quot;: &quot;_MASKED_&quot;&#125;</span><br></pre></td></tr></table></figure></div><p>关于<code>LogMasked</code>注解：</p><ul><li><code>Text</code>属性：自定义用于替换敏感数据的文本</li><li><code>ShowFirst</code>属性：显示明文的前几个字符，默认为<code>0</code></li><li><code>ShowLast</code>属性：显示明文的最后几个字符，默认为<code>0</code></li><li><code>PreserveLength</code>属性：是否显示与明文长度匹配的<code>*</code>，默认为<code>false</code></li></ul><p>或者使用<code>[NotLogged]</code>注解，Serilog将完全忽略该属性。</p><h2 id="Serilog异步处理"><a href="#Serilog异步处理" class="headerlink" title="Serilog异步处理"></a>Serilog异步处理</h2><p>Serilog的日志方法都是同步的，但储存日志需要时间，如果日志过多，调用线程将明显阻塞。这意味着，实际的Serilog日志记录器在幕后并不会同步执行工作，而是尽可能<strong>缓冲</strong>，然后<strong>异步地</strong>将日志推送到提供程序，或者说接收器（<code>sink</code>）。如何实现这个机制？</p><p><code>Serilog.Sinks.Async</code>包提供了一个异步接收器，可以异步地将日志写入另一个接收器，从而提高性能。这意味着，它可以为任何接收器提供异步处理能力，即使这些接收器本身是同步的。</p><p>以异步方式注册<code>File</code>接收器，从而提高日志写入文件的性能：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">.WriteTo.Async(x =&gt; x.File(<span class="string">&quot;log.txt&quot;</span>), <span class="number">10</span>)</span><br><span class="line">.CreateLogger();</span><br></pre></td></tr></table></figure></div><p>这时，Serilog会将日志消息放入缓冲区，在缓冲区满时异步地将它们写入文件。这里的<code>10</code>就表示缓冲区的大小为10条日志消息。如果你不指定缓冲区大小，Serilog也会保证日志的周期性写入。</p><p>在应用程序关闭时，调用<code>Log.CloseAndFlush()</code>确保所有缓冲的日志都写入接收器。</p><h2 id="自定义Sink"><a href="#自定义Sink" class="headerlink" title="自定义Sink"></a>自定义Sink</h2><p>实现<code>ILogEventSink</code>接口以自定义<code>Sink</code>，通常会聚合一个可空的<code>IFormatProvider</code>，以便在需要时格式化日志消息。</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyCustomSink</span> : <span class="title">ILogEventSink</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IFormatProvider? _formatProvider;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyCustomSink</span>(<span class="params">IFormatProvider? formatProvider</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">_formatProvider = formatProvider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyCustomSink</span>() : <span class="title">this</span>(<span class="params"><span class="literal">null</span></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Emit</span>(<span class="params">LogEvent logEvent</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 处理日志事件，例如将其写入自定义存储</span></span><br><span class="line"><span class="keyword">var</span> message = logEvent.RenderMessage(_formatProvider);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;log from MyCustomSink: <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><code>RenderMessage</code>方法：使用可选的格式提供程序渲染日志消息</li></ul><p>然后，在<code>LoggerConfiguration.WriteTo</code>属性上调用<code>Sink&lt;TSink&gt;</code>方法（前提是<code>MyCustomSink</code>有无参构造）：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">.WriteTo.Sink&lt;MyCustomSink&gt;()</span><br><span class="line">.CreateLogger();</span><br></pre></td></tr></table></figure></div><p>或者调用<code>Sink(ILogEventSink sink)</code>方法，并使用<code>MyCustomSink</code>的有参构造，更灵活：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">.WriteTo.Sink(<span class="keyword">new</span> MyCustomSink(someFormatProvider))</span><br><span class="line">.CreateLogger();</span><br></pre></td></tr></table></figure></div><p>如果你想跟其他Sinks提供一致的使用体验，可以创建<code>LoggerSinkConfiguration</code>的扩展方法（推荐）：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyCustomSinkExtensions</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoggerConfiguration <span class="title">MyCustomSink</span>(<span class="params"><span class="keyword">this</span> LoggerSinkConfiguration loggerConfiguration,</span></span></span><br><span class="line"><span class="params"><span class="function">IFormatProvider? formatProvider = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> loggerConfiguration.Sink(<span class="keyword">new</span> MyCustomSink(formatProvider));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">.WriteTo.MyCustomSink()</span><br><span class="line">.CreateLogger();</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;无论是作用域、&lt;code&gt;IsEnabled&lt;/code&gt;、格式化或消息模板的概念，还是结构化日志记录，&lt;code&gt;Serilog&lt;/code&gt;都是这些功能的开创者和标准化者。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对消息模板、结构化日志、参数解析等都有极佳的支持。&lt;/li&gt;
&lt;li&gt;</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET日志" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET日志(2)：Microsoft.Extensions.Logging包</title>
    <link href="https://blog.xicuodev.top/2025/12/12/dotnet-logging-2-microsoft-extensions-logging/"/>
    <id>https://blog.xicuodev.top/2025/12/12/dotnet-logging-2-microsoft-extensions-logging/</id>
    <published>2025-12-12T01:49:43.616Z</published>
    <updated>2026-01-25T11:46:11.559Z</updated>
    
    <content type="html"><![CDATA[<p><code>ILogger</code>并不是一个BCL（Basic Class Library，基础类库）接口，而是来自于<code>Microsoft.Extensions.Logging</code>包。如果你是一个类库作者，你可以引用<code>Microsoft.Extensions.Logging.Abstraction</code>抽象依赖，因为开发类库通常用不上这些具体实现。</p><ul><li><code>LoggerFactory</code>日志记录器工厂：<ul><li><code>Create</code>静态方法：创建一个工厂</li><li><code>CreateLogger&lt;&gt;</code>方法：创建一个日志记录器</li></ul></li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LoggerFactory.Create(builder =&gt; &#123; builder.AddConsole(); &#125;);</span><br><span class="line">ILogger logger = loggerFactory.CreateLogger&lt;Program&gt;();</span><br></pre></td></tr></table></figure></div><ul><li><code>ILogger</code>日志记录器：<ul><li><code>Log</code>方法：<code>logLevel</code>, <code>eventId</code>（<a href="#%E6%97%A5%E5%BF%97%E4%BA%8B%E4%BB%B6ID">事件ID</a>）, <code>message</code></li><li><code>LogInformation</code>等扩展方法：封装<code>Log</code>方法，常用</li></ul></li></ul><h2 id="结构化日志记录-语义化日志记录"><a href="#结构化日志记录-语义化日志记录" class="headerlink" title="结构化日志记录&#x2F;语义化日志记录"></a>结构化日志记录&#x2F;语义化日志记录</h2><p>不要使用字符串拼接、模板字符串或格式字符串来传递日志消息，这会导致具体的参数值“烘焙”到日志消息中，从而丢失<code>OriginalFormat</code>（原始格式）。我们希望捕获上下文、作用域、细节和信息，而这正是消息模板字符串和“结构化日志记录”所解决的问题。</p><ul><li><code>Microsoft.Extensions.Logging.Console</code>：<ul><li><code>ILoggingBuilder.AddJsonConsole</code>方法：控制台输出结构化的JSON日志</li></ul></li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> loggerFactory = LoggerFactory.Create(builder =&gt; &#123; builder.AddJsonConsole(); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logger = loggerFactory.CreateLogger&lt;Program&gt;();</span><br><span class="line"></span><br><span class="line">logger.LogInformation(<span class="string">&quot;Hello World! It is &#123;At&#125;.&quot;</span>, DateTime.UtcNow);</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;&quot;EventId&quot;:0,&quot;LogLevel&quot;:&quot;Information&quot;,&quot;Category&quot;:&quot;Program&quot;,&quot;Message&quot;:&quot;Hello World! It is 12/12/2025 02:17:20.&quot;,&quot;State&quot;:&#123;&quot;Message&quot;:&quot;Hello World! It is 12/12/2025 02:17:20.&quot;,&quot;At&quot;:&quot;12/12/2025 02:17:20&quot;,&quot;&#123;OriginalFormat&#125;&quot;:&quot;Hello World! It is &#123;At&#125;.&quot;&#125;&#125;</span></span><br></pre></td></tr></table></figure></div><h2 id="日志类别约定"><a href="#日志类别约定" class="headerlink" title="日志类别约定"></a>日志类别约定</h2><p>日志类别通常约定为注入或使用<code>ILogger&lt;类&gt;</code>的类名。从.NET 6开始，任何自动的依赖注入服务都不会自动注入非泛型的<code>ILogger</code>。</p><h2 id="日志级别约定"><a href="#日志级别约定" class="headerlink" title="日志级别约定"></a>日志级别约定</h2><p>默认情况下，无论是JSON控制台还是普通控制台，它们的最低日志级别都是<code>Information</code>，这意味着它们会完全忽略<code>Debug</code>或<code>Trace</code>级别的日志。</p><ul><li>要设置最低日志级别，使用<code>ILoggingBuilder.SetMinimumLevel</code>方法：</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.SetMinimumLevel(LogLevel.Trace);</span><br></pre></td></tr></table></figure></div><p>在现代应用程序中，尤其是ASP.NET Core中，这类配置通常会集中放在相应的<code>appsettings.json</code>文件中，或你正在使用的其他配置提供程序中。这会自动配置最低日志级别，无需在代码中手动配置。</p><h2 id="日志事件ID"><a href="#日志事件ID" class="headerlink" title="日志事件ID"></a>日志事件ID</h2><p>事件ID用于给一种类型的事件打标签，一个ID代表一种事件。</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.LogInformation(<span class="number">233</span>, <span class="string">&quot;ID为233的事件发生了。&quot;</span>);</span><br></pre></td></tr></table></figure></div><p>非常常见的一种做法是，人们会创建一个事件类，用于集中放置事件ID：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogEvents</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> SomeEvent = <span class="number">233</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>现代结构化日志框架有很多为日志打标签的替代方案，然而事件ID仍是一个非常强大的工具。</p><h2 id="主机应用-Host"><a href="#主机应用-Host" class="headerlink" title="主机应用 Host"></a>主机应用 Host</h2><p>主机通常需要长时间运行，并为客户提供服务，适用于后台工作进程，常见于Web框架。要在非主机控制台应用中使用主机，引入<code>Microsoft.Extensions.Hosting</code>包。</p><p><code>Logging</code>包提供主机<code>IHost</code>的<code>ConfigureLogging</code>扩展方法，接收<code>ILoggingBuilder</code>，从而为主机配置日志服务。</p><h2 id="自定义ILogger日志记录器与Provider日志提供程序"><a href="#自定义ILogger日志记录器与Provider日志提供程序" class="headerlink" title="自定义ILogger日志记录器与Provider日志提供程序"></a>自定义ILogger日志记录器与Provider日志提供程序</h2><p>配置<code>ILogger</code>日志记录器：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.AddJsonConsole().SetMinimumLevel(LogLevel.Trace);</span><br></pre></td></tr></table></figure></div><ul><li><code>ClearProviders</code>方法：清除之前添加的提供程序，从而接着可以换成你想要的</li></ul><p>配置<code>Provider</code>日志提供程序：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">builder.AddJsonConsole(options =&gt; &#123;  </span><br><span class="line">    options.IncludeScopes = <span class="literal">false</span>;  <span class="comment">//禁用作用域</span></span><br><span class="line">    options.TimestampFormat = <span class="string">&quot;[yyyy-MM-dd HH:mm:ss] &quot;</span>;  </span><br><span class="line">    options.JsonWriterOptions = <span class="keyword">new</span> JsonWriterOptions &#123;  </span><br><span class="line">    Indented = <span class="literal">true</span>  <span class="comment">//以缩进形式输出JSON</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#123;</span></span><br><span class="line"><span class="comment">    &quot;Timestamp&quot;: &quot;[2025-12-12 11:15:07] &quot;,</span></span><br><span class="line"><span class="comment">    &quot;EventId&quot;: 233,</span></span><br><span class="line"><span class="comment">    &quot;LogLevel&quot;: &quot;Information&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Category&quot;: &quot;Program&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Message&quot;: &quot;Hello World! It is 12/12/2025 03:15:07.&quot;,</span></span><br><span class="line"><span class="comment">    &quot;State&quot;: &#123;</span></span><br><span class="line"><span class="comment">        &quot;Message&quot;: &quot;Hello World! It is 12/12/2025 03:15:07.&quot;,</span></span><br><span class="line"><span class="comment">        &quot;At&quot;: &quot;12/12/2025 03:15:07&quot;,</span></span><br><span class="line"><span class="comment">        &quot;&#123;OriginalFormat&#125;&quot;: &quot;Hello World! It is &#123;At&#125;.&quot;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br></pre></td></tr></table></figure></div><h2 id="在appsettings-json中配置日志服务"><a href="#在appsettings-json中配置日志服务" class="headerlink" title="在appsettings.json中配置日志服务"></a>在<code>appsettings.json</code>中配置日志服务</h2><p>你不应该每次为了调整日志配置，都必须修改代码中的日志逻辑，并重新部署应用程序，而是应该将这些配置放在外部的配置文件中。</p><p><code>appsettings.json</code>是大多数类型的应用程序项目模板中的标准配置文件，包括针对特定环境的版本<code>appsettings.Development.json</code>和不区分环境的通用版本<code>appsettings.json</code>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/2025/12/12/dotnet-logging-2-microsoft-extensions-logging/%E5%9C%A8appsettings.json%E4%B8%AD%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1.webp"                                     ></p><h2 id="日志记录异常"><a href="#日志记录异常" class="headerlink" title="日志记录异常"></a>日志记录异常</h2><p>你可以捕获异常，并把它放到Log方法的第一个参数，来记录异常日志。</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Something went wrong&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">logger.LogWarning(ex, <span class="string">&quot;Failure during birthday of &#123;Name&#125; who is &#123;Age&#125;&quot;</span>, name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="日志过滤器"><a href="#日志过滤器" class="headerlink" title="日志过滤器"></a>日志过滤器</h2><p>通过<code>LoggingBuilder.AddFilter</code>方法设置日志过滤器，它接收返回布尔值的委托。这个委托可以不传参数，也可以传入提供程序 <code>provider</code>、类别 <code>category</code> 和级别 <code>logLevel</code>。之前设置最低日志级别时，背后就是用到了日志过滤器。</p><ul><li><code>AddFilter&lt;SomeProvider&gt;(类别, 级别)</code>可以针对<code>SomeProvider</code>过滤。</li></ul><p>不过，这种方式更可能在你为他人开发类库时派上用场，而不是在构建微服务这类服务时，因为大多数配置实际上都会放在你的 <code>appsettings.json</code> 中。但知道你拥有灵活性，以备不时之需，总是好的。</p><h2 id="日志提供程序-LoggerProvider"><a href="#日志提供程序-LoggerProvider" class="headerlink" title="日志提供程序 LoggerProvider"></a>日志提供程序 LoggerProvider</h2><p>控制台是临时日志提供程序，一旦停止运行，它和它的日志缓存就不存在了，它们不是持久化的。相反，文件系统就是能够持久存储日志的提供程序。</p><ul><li>ASP.NET Core 显式或隐式内置了 <code>Microsoft.Extensions.Logging</code> 的 <code>Console</code>、<code>Debug</code>、<code>EventLog</code>、<code>EventSource</code> 和 <code>TraceSource</code> 提供程序。</li><li>Microsoft Azure 的云端日志提供程序：<code>ApplicaitonInsights</code>。</li></ul><p>在控制台中配置 <code>ApplicaitonInsights</code> 提供程序：</p><ul><li>引入NuGet包：<ul><li><code>Microsoft.ApplicaitonInsights</code></li><li><code>Microsoft.Extensions.DependencyInjection</code></li><li><code>Microsoft.Extensions.Options.ConfigurationExtensions</code></li><li><code>Microsoft.Extensions.Logging</code></li><li><code>Microsoft.Extensions.Logging.ApplicaitonInsights</code></li></ul></li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> channel = <span class="keyword">new</span> InMemoryChannel();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">IServiceCollection services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.Configure&lt;TelemetryConfiguration&gt;(x =&gt; x.TelemetryChannel = channel);</span><br><span class="line">services.AddLogging(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">x.AddApplicationInsights(</span><br><span class="line">configureTelemetryConfiguration: teleConfig =&gt;</span><br><span class="line">teleConfig.ConnectionString = <span class="string">&quot;your_connection_string&quot;</span>,</span><br><span class="line">configureApplicationInsightsLoggerOptions: _ =&gt; &#123;&#125;</span><br><span class="line">);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> serviceProvider = services.BuildServiceProvider();</span><br><span class="line"><span class="keyword">var</span> logging = serviceProvider.GetRquiredService&lt;ILogger&lt;Program&gt;&gt;();</span><br><span class="line">logging.LogInformation(<span class="string">&quot;Hello from console!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">await</span> channel.FlushAsync(<span class="literal">default</span>);</span><br><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="根据不同的运行环境配置不同的日志提供程序"><a href="#根据不同的运行环境配置不同的日志提供程序" class="headerlink" title="根据不同的运行环境配置不同的日志提供程序"></a>根据不同的运行环境配置不同的日志提供程序</h2><p>在生产环境中，你不希望日志泛滥。你需要对日志行为非常精准地控制，像在生产环境中使用控制台日志记录，可能会拖垮应用程序的性能。在 ASP.NET Core 中，<code>builder.Environment.IsDevelopment</code>方法可以返回当前是否在开发环境。</p><ul><li>这里要获取<code>ILoggingBuilder</code>，使用<code>builder.Logging</code>属性。</li><li>与开发环境（<code>Development</code>）平行的是生产环境（<code>Production</code>）。</li></ul><h2 id="自定义日志提供程序"><a href="#自定义日志提供程序" class="headerlink" title="自定义日志提供程序"></a>自定义日志提供程序</h2><p>要自定义日志提供程序，实现<code>ILogger</code>和<code>ILoggerProvider</code>接口，并在你的<code>LoggerProvider</code>的<code>CreateLogger</code>方法中返回你的<code>Logger</code>。</p><ul><li><code>ILogger</code>接口：<ul><li><code>TState</code>泛型：包含实际日志消息的参数的泛型</li><li><code>BeginScope</code>方法：开启作用域</li><li><code>IsEnabled</code>方法：返回是否启用</li><li><code>Log</code>方法：如果启用，记录日志</li></ul></li></ul><h2 id="日志消息模板字符串"><a href="#日志消息模板字符串" class="headerlink" title="日志消息模板字符串"></a>日志消息模板字符串</h2><ul><li><code>{Total:C}</code>：当前文化的货币格式</li><li><code>{Date:F}</code>：当前文化的日期完整格式</li><li><code>{Date:u}</code>：universal sortable date，通用可排序日期格式</li></ul><p>要实现复杂类型数据的格式化和结构化，你不得不使用<code>JsonSerializer</code>。此时，如果你又要使用<code>JsonConsole</code>，会出现JSON嵌套在JSON中的情况，你必须谨慎处理这里的序列化过程。</p><h2 id="日志作用域-Log-Scope"><a href="#日志作用域-Log-Scope" class="headerlink" title="日志作用域 Log Scope"></a>日志作用域 Log Scope</h2><p>在代码中，存在一段从开始到结束都需要处理特定上下文的区域，这个上下文可能是某种特定的支付、特定的订单、购物车，或者任何在你的业务领域中有意义的内容。尽管一些日志是独立的，但它们所关联的大量数据都与特定的上下文相关。</p><ul><li><code>JsonConsole</code>的<code>Options</code>：<ul><li><code>IncludeScopes</code>属性：是否包含作用域；为<code>true</code>时，结果中将出现<code>Scopes</code>属性，它是一个数组，包含所有上下文数据</li></ul></li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (logging.BeginScope(<span class="string">&quot;&#123;PaymentId&#125;&quot;</span>, paymentId))</span><br><span class="line"><span class="keyword">using</span> (logging.BeginScope(<span class="string">&quot;&#123;TotalAmount:C&#125;&quot;</span>, amount))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">logger.LogInformation(<span class="string">&quot;New payment processing&quot;</span>);</span><br><span class="line"><span class="comment">//processing new payment</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">logger.LogInformation(<span class="string">&quot;Payment processing completed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><code>PaymentId</code>和<code>TotalAmount</code>将作为上下文数据由作用域内的所有日志共享，它们将包含在这些日志的<code>Scopes</code>数组中。</li></ul><h2 id="检查日志是否启用"><a href="#检查日志是否启用" class="headerlink" title="检查日志是否启用"></a>检查日志是否启用</h2><p>虽然日志提供程序通常都会在<code>Log</code>方法的开头检查是否启用，但是为以防万一，你应该在自己的代码中也加入<code>IsEnabled</code>的判断，以确保没有性能问题。</p><h2 id="日志记录操作耗时"><a href="#日志记录操作耗时" class="headerlink" title="日志记录操作耗时"></a>日志记录操作耗时</h2><p>下面是利用<code>Stopwatch</code>类和日志上下文机制记录操作耗时的方法。</p><p><code>Stopwatch</code>类是.NET中测量时间最精确的方案：</p><ul><li><code>GetTimestamp</code>静态方法：获取当前时间戳</li><li><code>GetElapsedTime</code>静态方法：获取传入时间戳到现在的时间间隔</li></ul><p>可以用<code>Stopwatch</code>类结合作用域机制，获取并记录操作耗时。</p><p>创建<code>TimedOperation</code>类，聚合<code>_logger</code>、<code>_logLevel</code>、<code>_eventId</code>、<code>_message</code> 和 <code>_args</code>，实现<code>IDisposable</code>接口：</p><ul><li>在构造方法中获取当前时间戳</li><li>在<code>Dispose</code>方法获取时间间隔，并调用<code>_logger.Log</code>方法记录耗时日志</li></ul><p>创建<code>TimedOperationExtensions</code>类，扩展以支持<code>ILogger</code>接口：</p><ul><li><code>BeginTimedOperation</code>方法：创建并返回<code>TimedOperation</code>对象，用作上下文数据</li><li>创建一个不传入<code>LogLevel</code>的<code>BeginTimedOperation</code>方法重载，并默认使用<code>Information</code>级别</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (logger.BeginTimedOperation(<span class="string">&quot;Handling new payment&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">logger.LogInformation(<span class="string">&quot;New payment processing&quot;</span>);</span><br><span class="line"><span class="comment">//processing new payment</span></span><br><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="运行时动态修改最低日志级别"><a href="#运行时动态修改最低日志级别" class="headerlink" title="运行时动态修改最低日志级别"></a>运行时动态修改最低日志级别</h2><p>在你的应用程序中，只要支持在运行时热重载或动态重载<code>appsettings.json</code>配置文件，就可以实现运行时动态修改最低日志级别这一功能。而这就是配置提供程序要做的事情了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;&lt;code&gt;ILogger&lt;/code&gt;并不是一个BCL（Basic Class</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET日志" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET日志(1)：概论</title>
    <link href="https://blog.xicuodev.top/2025/12/12/dotnet-logging-1-introduction/"/>
    <id>https://blog.xicuodev.top/2025/12/12/dotnet-logging-1-introduction/</id>
    <published>2025-12-12T01:16:40.993Z</published>
    <updated>2026-01-25T11:46:42.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日志类别-Log-Category"><a href="#日志类别-Log-Category" class="headerlink" title="日志类别 Log Category"></a>日志类别 Log Category</h2><p>日志类别只是一种逻辑方式，用于将不同的日志条目归类到某种统一的分组下。例如，如果你正在运行一个API，微软会将其自身的所有日志归类在<code>Microsoft.Asp.Core</code>这个类别或分组下，你也可以控制自己的日志类别。</p><ul><li><code>ILogger&lt;类&gt;</code>：通常是当前类，如<code>ILogger&lt;Program&gt;</code></li><li><code>LogInformation</code>方法：打印<code>info</code>级别的日志</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info: Program[0]</span><br><span class="line">      Hello World!</span><br></pre></td></tr></table></figure></div><ul><li><code>Program</code>：日志类别</li><li><code>[0]</code>：<a href="/2025/12/12/dotnet-logging-2-microsoft-extensions-logging/#%E6%97%A5%E5%BF%97%E4%BA%8B%E4%BB%B6ID" title=".NET日志(2)：Microsoft.Extensions.Logging包">事件ID</a></li></ul><h2 id="日志级别-Log-Level"><a href="#日志级别-Log-Level" class="headerlink" title="日志级别 Log Level"></a>日志级别 Log Level</h2><p>日记级别代表日志的严重程度：<code>Trace</code>&lt;…&lt;<code>Critical</code>，详见<code>LogLevel</code>枚举。</p><ul><li><code>Trace</code>包含最详细的记录，甚至可以是敏感记录，不能用于生产环境，默认禁用。</li><li><code>Debug</code>用于在开发过程中调试程序，一般不用于生产环境。</li><li><code>Information</code>一般是默认的级别，用于跟踪应用程序的一般流程，可以存储并具有长期价值。</li><li><code>Warning</code>用于突出异常或意外情况，但并不意味着应用程序崩溃、停止或存在根本性错误。</li><li><code>Error</code>表示确实崩溃了，应用程序遇到了无法处理的异常。</li><li><code>Critical</code>表示彻底崩溃，应用程序遇到了不可挽回的致命错误。</li></ul><h2 id="日志提供程序-Log-Provider"><a href="#日志提供程序-Log-Provider" class="headerlink" title="日志提供程序 Log Provider"></a>日志提供程序 Log Provider</h2><p>日志提供程序是日志的输出目标。目标可以是任何东西，它可以是控制台、事件日志、数据库、第三方服务……任何地方。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;日志类别-Log-Category&quot;&gt;&lt;a href=&quot;#日志类别-Log-Category&quot; class=&quot;headerlink&quot; title=&quot;日志类别 Log Category&quot;&gt;&lt;/a&gt;日志类别 Log</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET日志" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>C#常见集合接口</title>
    <link href="https://blog.xicuodev.top/2025/08/26/cs-common-collections-api/"/>
    <id>https://blog.xicuodev.top/2025/08/26/cs-common-collections-api/</id>
    <published>2025-08-26T07:11:00.000Z</published>
    <updated>2026-01-22T13:42:23.653Z</updated>
    
    <content type="html"><![CDATA[<p>下面只列出泛型接口，没有泛型的版本的接口处理数据的逻辑差不多，只是需要装拆箱。</p><ul><li><code>IEnumerable&lt;TItem&gt;</code>：可迭代、可枚举类型<ul><li><code>GetEnumerator</code> 方法：获取迭代器&#x2F;枚举器</li></ul></li><li><code>IEnumerator&lt;TItem&gt;</code>：枚举器，初始不指向任何元素，要调用一次<code>MoveNext</code>方法启动枚举器<ul><li><code>Current</code>属性：当前元素，只<code>get</code></li><li><code>MoveNext</code>方法：启动枚举器，让它指向首个元素（初始）；移动枚举器，让它指向下一个元素（非初始）</li><li><code>Reset</code> 方法：重置枚举器到初始状态</li></ul></li><li><code>ICollection&lt;TItem&gt;</code>：集合<ul><li><code>Add</code> 方法</li><li><code>Remove</code> 方法</li></ul></li><li><code>IList&lt;TItem&gt;</code>：列表<ul><li><code>[int index]</code> 索引器：指定索引的元素，<code>get</code>和<code>set</code></li><li><code>IsFixedSize</code>属性：有无固定大小，只<code>get</code></li><li><code>IsReadOnly</code>属性：是否只读，只<code>get</code></li><li><code>Count</code>属性：元素个数，只<code>get</code></li><li><code>IsSynchronized</code>属性</li><li><code>SyncRoot</code>属性</li><li><code>Add</code>方法</li><li><code>Clear</code>方法</li><li><code>Contains</code>方法</li><li><code>CopyTo</code>方法</li><li><code>GetEnumerator</code>方法</li><li><code>IndexOf</code>方法</li><li><code>Insert</code>方法</li><li><code>Remove</code>方法</li><li><code>RemoveAt</code>方法</li></ul></li><li><code>IDictionary&lt;TKey, TValue&gt;</code>：字典</li></ul><p>来源：<a class="link"   href="https://www.bilibili.com/video/BV13b411b7Ht" >刘铁猛《C#语言入门详解》全集<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;下面只列出泛型接口，没有泛型的版本的接口处理数据的逻辑差不多，只是需要装拆箱。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IEnumerable&amp;lt;TItem&amp;gt;&lt;/code&gt;：可迭代、可枚举类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GetEnumerator&lt;/code&gt;</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term="C#基础" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/C-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
