<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>系错的技术博客</title>
  
  <subtitle>好用、美观</subtitle>
  <link href="https://blog.xicuodev.top/atom.xml" rel="self"/>
  
  <link href="https://blog.xicuodev.top/"/>
  <updated>2026-01-26T04:47:02.896Z</updated>
  <id>https://blog.xicuodev.top/</id>
  
  <author>
    <name>xicuod</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>.NET多线程(4)：线程安全</title>
    <link href="https://blog.xicuodev.top/2026/01/26/dotnet-multithreading-4-safety/"/>
    <id>https://blog.xicuodev.top/2026/01/26/dotnet-multithreading-4-safety/</id>
    <published>2026-01-26T04:08:04.397Z</published>
    <updated>2026-01-26T04:47:02.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程亲和性-Thread-Affinity"><a href="#线程亲和性-Thread-Affinity" class="headerlink" title="线程亲和性 Thread Affinity"></a>线程亲和性 Thread Affinity</h2><ul><li>在工作线程中访问主线程中的资源时，需要同步上下文</li><li>主线程中的资源一般会提供<code>Invoke</code>方法</li><li><code>Invoke</code>方法：传递委托，委托的方法体上下文就是同步上下文</li><li><code>InvokeRequired</code>属性：是否需要调用<code>Invoke</code>方法；如果方法是在主线程调用，那么就不能用<code>Invoke</code>方法</li></ul><h2 id="线程安全-Thread-Safety"><a href="#线程安全-Thread-Safety" class="headerlink" title="线程安全 Thread Safety"></a>线程安全 Thread Safety</h2><p>当一个函数、数据结构或类可以被多个线程并发使用，而不会产生竞态条件、不一致行为或数据损坏时，它就是线程安全的。</p><ul><li>线程安全的语法实体内部已经使用了适当的同步机制，使用它们时不需要另外采取线程同步措施。</li></ul><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>线程的生命周期开始于 <code>System.Threading.Thread</code>类的实例被创建时，结束于线程被终止或执行完成时。</p><ul><li>未启动状态：当线程实例被创建，但<code>Start</code>方法未被调用时</li><li>就绪状态：当线程准备好运行，并等待CPU周期时</li><li>不可运行状态：调用了<code>Sleep</code>方法；调用了<code>Wait</code>方法；通过I&#x2F;O操作阻塞</li><li>死亡状态：当线程已经执行完毕，或已经终止时</li></ul><h2 id="让线程等待一段时间"><a href="#让线程等待一段时间" class="headerlink" title="让线程等待一段时间"></a>让线程等待一段时间</h2><ul><li><code>Thread.Sleep(毫秒数)</code>：线程将被调度器踢出CPU，为不可运行状态，即<code>WaitSleepJoin</code>状态</li><li><code>Thread.SpinWait(次数)</code>：相当于<code>for</code>循环，线程会被保持在CPU内，只是繁忙等待；但如果占用CPU时间太长，超过分配时间片，仍会被调度器踢出</li><li><code>SpinWait.SpinUntil(条件,超时毫秒数)</code>：繁忙等待，直到满足条件或超时</li><li>后两种方法谨慎使用，小心耗尽CPU资源</li></ul><h2 id="从线程中返回结果"><a href="#从线程中返回结果" class="headerlink" title="从线程中返回结果"></a>从线程中返回结果</h2><ul><li><code>Thread</code>类没有内置的方法返回结果，更好的选择是<code>Task</code>类</li><li><code>Thread</code>类返回结果的唯一方式是共享变量</li></ul><h2 id="线程取消-Thread-Cancellation"><a href="#线程取消-Thread-Cancellation" class="headerlink" title="线程取消 Thread Cancellation"></a>线程取消 Thread Cancellation</h2><ul><li>设置一个共享的标志变量，如 bool cancelThread</li><li>更好的做法：CancellationTokenSource类，详见任务取消</li></ul><h2 id="线程池-Thread-Pool"><a href="#线程池-Thread-Pool" class="headerlink" title="线程池 Thread Pool"></a>线程池 Thread Pool</h2><ul><li>创建和释放线程需要时间和空间，每次都创建新的性能很差</li><li>每个应用程序都有一个线程池，并定义了最大和最小线程数</li></ul><p>线程池的行为：</p><ul><li>达到最小值之前，每次都创建新线程</li><li>达到最小值之后，每次用空闲的，只有都繁忙，才创建新线程</li><li>达到最大值之后，如果都繁忙，只能排队等待空闲线程</li></ul><h2 id="工作线程的异常处理"><a href="#工作线程的异常处理" class="headerlink" title="工作线程的异常处理"></a>工作线程的异常处理</h2><ul><li>每个线程都有自己的调用堆栈，工作线程抛出的异常永远不会到达主线程</li><li>简单的做法是在工作线程内使用<code>try-catch</code>块，并自行处理</li><li>更好的做法是使用共享资源，创建一个异常列表 <code>List&lt;Exception&gt;</code>，在工作线程中<code>catch</code>异常并将其加入列表，并在主线程统一处理</li><li>更更好的做法是使用<code>Task</code>类，它有内置的异常处理机制</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;线程亲和性-Thread-Affinity&quot;&gt;&lt;a href=&quot;#线程亲和性-Thread-Affinity&quot; class=&quot;headerlink&quot; title=&quot;线程亲和性 Thread Affinity&quot;&gt;&lt;/a&gt;线程亲和性 Thread</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET多线程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET多线程(3)：线程交互</title>
    <link href="https://blog.xicuodev.top/2026/01/26/dotnet-multithreading-3-interaction/"/>
    <id>https://blog.xicuodev.top/2026/01/26/dotnet-multithreading-3-interaction/</id>
    <published>2026-01-26T03:51:03.808Z</published>
    <updated>2026-01-26T04:07:56.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 <code>Semaphore</code></h2><ul><li>信号量主要用于控制并发线程或进程（指定名称）的个数，一般不用于保护临界区</li><li><code>SemaphoreSlim</code>类（<code>Semaphore</code>类的精简版，没有跨进程功能，后者有）<ul><li>参数：<code>initialCount</code>：初始个数；<code>maxCount</code>：最大个数；倒计数，每次获取时减1</li></ul></li><li><code>Wait</code>方法：获取一个信号量，如果信号量不足，则阻塞</li><li><code>Release</code>方法：释放一个信号量</li><li><code>Wait</code>和<code>Release</code>不必在同一线程中（信号量不具有线程亲和性）</li><li><code>SemaphoreSlim</code>对象使用非托管资源，使用<code>using</code>避免内存泄漏</li><li>在Web服务器示例中，在请求队列的监控线程获取信号量，并在请求处理线程释放信号量，实现有限个监控线程并发（这里信号量不用于保护临界区，因此别忘了给入队出队的逻辑加写锁）</li></ul><h2 id="自动重置事件-AutoResetEvent"><a href="#自动重置事件-AutoResetEvent" class="headerlink" title="自动重置事件 AutoResetEvent"></a>自动重置事件 <code>AutoResetEvent</code></h2><ul><li>自动重置事件用于信号传递（Signaling）</li><li>典型应用：生产者-消费者场景<ul><li>生产者线程生产了足够资源时，向消费者线程传递布尔类型信号</li><li>如果生产者足够快，消费者线程就能并发</li><li>但如果生产者过于快，就会造成资源浪费，为此你需要把产品放入队列中</li></ul></li><li>构造器参数：<code>bool initialState</code>：初始状态，如果初始时已经有资源，可以设为<code>true</code></li><li><code>WaitOne</code>方法：等待信号，阻塞</li><li><code>Set</code>方法：设置信号</li><li><code>AutoResetEvent</code>对象使用非托管资源，使用<code>using</code>避免内存泄漏</li></ul><h2 id="手动重置事件-ManualResetEvent"><a href="#手动重置事件-ManualResetEvent" class="headerlink" title="手动重置事件 ManualResetEvent"></a>手动重置事件 <code>ManualResetEvent</code></h2><ul><li>在自动重置事件中，一旦有线程持有信号，信号将自动重置；而在手动重置事件中，你需要调用<code>Reset</code>方法手动重置信号</li><li>典型应用：在分治法中，每次都需要多个工作线程并发运行</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;信号量-Semaphore&quot;&gt;&lt;a href=&quot;#信号量-Semaphore&quot; class=&quot;headerlink&quot; title=&quot;信号量 Semaphore&quot;&gt;&lt;/a&gt;信号量</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET多线程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET多线程(2)：线程同步</title>
    <link href="https://blog.xicuodev.top/2026/01/25/dotnet-multithreading-2-synchronization/"/>
    <id>https://blog.xicuodev.top/2026/01/25/dotnet-multithreading-2-synchronization/</id>
    <published>2026-01-25T11:41:53.932Z</published>
    <updated>2026-01-25T12:53:28.880Z</updated>
    
    <content type="html"><![CDATA[<ul><li>共享资源：并发的线程竞争共享资源，造成冲突和资源争抢</li></ul><p>非原子操作与原子操作：</p><ul><li>非原子操作：可以拆分的操作，如 <code>count++</code> 实则为先 <code>temp+1</code> 再赋值给 <code>count</code>，缓存天然缺乏时效性，造成不一致行为和竞态条件</li><li>原子操作：不可拆分的操作，调度器不能中断它而去执行其他线程</li></ul><p>临界区与线程同步：</p><ul><li>临界区 (critical section)：线程中访问共享资源的操作区域，它应该是原子的</li><li>线程同步 (thread synchronization)：解决资源争抢的问题，你方唱罢我登场（舞台是共享的）</li></ul><h2 id="非原子操作为什么导致不一致行为？"><a href="#非原子操作为什么导致不一致行为？" class="headerlink" title="非原子操作为什么导致不一致行为？"></a>非原子操作为什么导致不一致行为？</h2><ol><li>你缓存A的值，还未加1，分配给你的时间片就到了，于是调度器将你挂起，让我执行</li><li>我给A加了1，调度器再让你执行，这时你的缓存已经丢失了时效性，你现在是给过去的A加1，再赋值给现在的A，污染了现在的A</li></ol><h2 id="两种常见的锁机制：写锁和读锁"><a href="#两种常见的锁机制：写锁和读锁" class="headerlink" title="两种常见的锁机制：写锁和读锁"></a>两种常见的锁机制：写锁和读锁</h2><ul><li>排它锁&#x2F;写锁&#x2F;X锁 (Exclusive Lock)：当一个线程持有写锁时，其他线程既不能获取写锁，也不能获取读锁</li><li>共享锁&#x2F;读锁&#x2F;S锁 (Shared Lock)：当一个线程持有读锁时，其他线程不能获取写锁，只能获取读锁</li></ul><p>如果一个线程不能获取它想要的锁，它将阻塞并等待该锁释放；例如：线程获取读锁时，如果有其他线程持有写锁，则阻塞</p><h2 id="NET线程同步的4个实现"><a href="#NET线程同步的4个实现" class="headerlink" title=".NET线程同步的4个实现"></a>.NET线程同步的4个实现</h2><h3 id="lock关键字（写锁）"><a href="#lock关键字（写锁）" class="headerlink" title="lock关键字（写锁）"></a><code>lock</code>关键字（写锁）</h3><p><code>lock(锁对象) { 锁主体(通常是临界区) }</code></p><p>锁主体同时只能由一个线程执行，即持有锁对象的线程；锁主体表现的就像是原子操作</p><ul><li>在 .NET 8&#x2F;C# 12（含）以前，使用一个<code>object</code>对象当作锁对象即可</li><li>在 .NET 9&#x2F;C# 13（含）以后，有专门的<code>System.Threading.Lock</code>对象</li></ul><p>锁主体中隐含<code>try-finally</code>机制，在<code>finally</code>中会释放锁对象，因此不必担心锁主体抛出异常，导致锁对象无法释放</p><h3 id="监视器-Monitor（写锁）"><a href="#监视器-Monitor（写锁）" class="headerlink" title="监视器 Monitor（写锁）"></a>监视器 <code>Monitor</code>（写锁）</h3><ul><li>监视器：监视临界区，如果有一个线程进入临界区，就让其他线程阻塞等待<ul><li><code>lock</code>关键字是监视器的语法糖，因此监视器可以提供比<code>lock</code>更细粒度的控制</li></ul></li><li><code>Monitor.Enter(锁对象)</code>：进入临界区，如果锁对象已经被持有，就阻塞等待（如果锁一直得不到释放，会导致无限等待）</li><li><code>Monitor.Exit(锁对象)</code>：退出临界区，释放锁对象<ul><li>使用<code>try-finally</code>机制，在<code>finally</code>中调用<code>Exit</code>方法，以确保始终释放锁对象（监视器需要手动释放锁对象）</li></ul></li><li><code>Monitor.TryEnter(锁对象,等待时间)</code> ：如果锁对象被持有，就先等待一段时间；如果时间到了锁还是没有释放，就返回<code>false</code>，你可据此设计请求超时的分支逻辑；否则返回<code>true</code>（不会导致无限等待，或长时间等待，这会让用户无所适从，对用户不友好）</li></ul><h3 id="互斥锁-Mutex（写锁）"><a href="#互斥锁-Mutex（写锁）" class="headerlink" title="互斥锁 Mutex（写锁）"></a>互斥锁 <code>Mutex</code>（写锁）</h3><ul><li>互斥锁是写锁的一种跨进程实现，而监视器只能在同一进程内使用</li><li>互斥锁在操作系统中使用，因此需要保证其名称进程间唯一<ul><li>创建互斥锁比创建监视器需要更多资源，除非你需要跨进程同步，否则不应使用互斥锁</li></ul></li><li>互斥锁构造器：<code>new Mutex(false, &quot;GlobalMutex&quot;)</code><ul><li>参数1：初始所有权</li><li>参数2：互斥锁名称，只有命了名的互斥锁才能跨进程共享</li></ul></li><li><code>Mutex</code>对象使用非托管资源（不由编译器托管），需要程序自行释放；创建对象时，使用<code>using</code>关键字让编译器帮你在合适的时机释放它：<code>using var mutex = new Mutex()</code></li><li><code>WaitOne</code>方法：阻塞等待以获取该互斥锁</li><li><code>ReleaseMutex</code>方法：释放该互斥锁（这不是从内存释放<code>Mutex</code>对象！）</li></ul><h3 id="读写锁-ReaderWriterLock（写锁-读锁）"><a href="#读写锁-ReaderWriterLock（写锁-读锁）" class="headerlink" title="读写锁 ReaderWriterLock（写锁&amp;读锁）"></a>读写锁 <code>ReaderWriterLock</code>（写锁&amp;读锁）</h3><ul><li><code>ReaderWriterLockSlim</code>类（<code>ReaderWriterLock</code>类的精简改进版）<ul><li>获取&#x2F;释放写锁：<code>(Try)EnterWriteLock</code>和<code>ExitWriteLock</code>方法</li><li>获取&#x2F;释放读锁：<code>(Try)EnterReadLock</code>和<code>ExitReadLock</code>方法</li></ul></li><li><code>ReaderWriterLockSlim</code>对象使用非托管资源，使用<code>using</code>避免内存泄漏</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;ul&gt;
&lt;li&gt;共享资源：并发的线程竞争共享资源，造成冲突和资源争抢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非原子操作与原子操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非原子操作：可以拆分的操作，如 &lt;code&gt;count++&lt;/code&gt; 实则为先 &lt;code&gt;temp+1&lt;/code&gt;</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET多线程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET多线程(1)：多线程基础</title>
    <link href="https://blog.xicuodev.top/2026/01/25/dotnet-multithreading-1-basic/"/>
    <id>https://blog.xicuodev.top/2026/01/25/dotnet-multithreading-1-basic/</id>
    <published>2026-01-25T11:37:20.835Z</published>
    <updated>2026-01-25T11:45:47.927Z</updated>
    
    <content type="html"><![CDATA[<p>这几篇.NET多线程笔记写于2025年11月底-12月初。</p><h2 id="进程、线程与线程调度器"><a href="#进程、线程与线程调度器" class="headerlink" title="进程、线程与线程调度器"></a>进程、线程与线程调度器</h2><ul><li>进程 (process)：一个应用程序包含一个或多个进程，每个进程包含一个或多个线程</li><li>线程 (thread)：线程是CPU工作的基本单位，CPU只能看到一个个线程</li><li>线程调度器 (thread scheduler)：一块CPU核心同一时刻只能执行一条线程，因此需要调度器管理线程的执行<ul><li>线程调度器是操作系统的一部分，应用程序开发者不可控制</li></ul></li><li>时间片：由操作系统分配的每个线程一次占据CPU的时间，每轮每条线程的时间片执行完后重新分配</li></ul><p>主线程与工作线程：</p><ul><li>主线程：每个应用进程至少有一个主线程</li><li>工作线程：应用进程中主线程之外的其他线程</li></ul><p>单线程进程与多线程进程：</p><ul><li>单线程进程：只有一个主线程的进程</li><li>多线程进程：拥有一个主线程和多个工作线程的进程</li></ul><h2 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h2><ul><li>并发：对于多核的CPU，同一时刻会有多条线程在不同的CPU核心上并发地执行<ul><li>单核CPU没有真正的并发，它的多任务场景只是极快速地交替执行多个线程</li></ul></li><li>多线程实现“分而治之” (divide and conquer)：把数组的累加工作分成多份，交给不同的线程完成</li><li>阻塞：使用<code>Join</code>方法，让被调线程阻塞主调线程，直到阻塞队列执行完毕，主调线程才能继续执行</li><li>用工作线程卸载 (offload) 长时间运行的任务：否则它将阻塞主线程（在GUI应用中就是UI线程，从而导致UI长时间未响应，对用户不友好）</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;这几篇.NET多线程笔记写于2025年11月底-12月初。&lt;/p&gt;
&lt;h2 id=&quot;进程、线程与线程调度器&quot;&gt;&lt;a href=&quot;#进程、线程与线程调度器&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET多线程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET日志(5)：监控与告警</title>
    <link href="https://blog.xicuodev.top/2025/12/18/dotnet-logging-5-monitoring-and-alerting/"/>
    <id>https://blog.xicuodev.top/2025/12/18/dotnet-logging-5-monitoring-and-alerting/</id>
    <published>2025-12-18T09:54:11.788Z</published>
    <updated>2026-01-25T11:45:51.979Z</updated>
    
    <content type="html"><![CDATA[<p>监控涉及系统中的事件或指标，并基于这些数据采取行动，主要目的是为了及时发现并告警系统异常、性能瓶颈或业务逻辑问题。任何停机、任何严重错误、任何95%的性能下降等问题，都能基于基于推送至某一平台的日志非常容易地检测到，每个具备一定监控能力的平台都会有自己的<strong>告警系统</strong>。</p><p>在Application Insights中，监视器（Monitor）-告警（Alerts）允许用户基于日志数据创建监控规则，并在满足特定条件时触发告警通知。告警规则可以基于各种指标和日志查询来定义，例如响应时间、错误率、请求数量等。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/2025/12/18/dotnet-logging-5-monitoring-and-alerting/ApplicationInsights%E5%91%8A%E8%AD%A6.webp"                                     ></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;监控涉及系统中的事件或指标，并基于这些数据采取行动，主要目的是为了及时发现并告警系统异常、性能瓶颈或业务逻辑问题。任何停机、任何严重错误、任何95%的性能下降等问题，都能基于基于推送至某一平台的日志非常容易地检测到，每个具备一定监控能力的平台都会有自己的&lt;strong&gt;告警</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET日志" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET日志(4)：性能优化</title>
    <link href="https://blog.xicuodev.top/2025/12/17/dotnet-logging-4-performance/"/>
    <id>https://blog.xicuodev.top/2025/12/17/dotnet-logging-4-performance/</id>
    <published>2025-12-17T02:58:20.929Z</published>
    <updated>2026-01-25T11:45:59.292Z</updated>
    
    <content type="html"><![CDATA[<p>日志是一个<strong>切面关注点</strong>，日志的记录会影响整个系统的性能。在程序的<strong>热点路径</strong>上，日志记录的开销可能会显著影响应用程序的响应时间和吞吐量，这些日志必须非常轻量、非常高效。</p><p>使用日志消息模板字符串时，为了结构化日志，每记录一条日志，日志记录器都需要创建这些参数的数组，并对参数装箱（因为是<code>object[]</code>数组）。日志一多，会造成大量内存开销。要优化它，可以使用<code>LoggerMessage.Define</code>方法来预定义日志消息模板，从而避免在每次记录日志时的装箱和数组分配。</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Action&lt;ILogger, <span class="built_in">int</span>, Exception?&gt; _logUserLoggedIn =</span><br><span class="line">    LoggerMessage.Define&lt;<span class="built_in">int</span>&gt;(LogLevel.Information,</span><br><span class="line">      <span class="keyword">new</span> EventId(<span class="number">1</span>, <span class="keyword">nameof</span>(UserLoggedIn)),</span><br><span class="line">      <span class="string">&quot;User &#123;UserId&#125; has logged in.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UserLoggedIn</span>(<span class="params"><span class="built_in">int</span> userId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 一些业务代码 */</span></span><br><span class="line">  _logUserLoggedIn(_logger, userId, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><code>Action</code>委托使用泛型以<strong>强类型参数</strong>传入（如 <code>int</code>），减少装箱并更易被JIT优化&#x2F;内联。</li><li><code>Define</code>方法内部会对每种不同参数个数的消息模板使用特定<strong>格式化器</strong>，避免了数组分配。</li><li><code>&quot;User {UserId} has logged in.&quot;</code>是一个编译时常量，会在内存中驻留（interned）。</li></ul><p>这种写法比较繁琐，要解决这个问题，使用<strong>Source Generator</strong>（源代码生成器，由<code>Microsoft.Extensions.Logging.Generators</code>提供）在编译时生成代码，你只需使用<code>LoggerMessage</code>注解声明<code>ILogger</code>的扩展方法：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">LoggerExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">LoggerMessage(EventId = 1, Level = LogLevel.Information, Message = <span class="string">&quot;User &#123;UserId&#125; has logged in.&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">LogUserLoggedIn</span>(<span class="params"><span class="keyword">this</span> ILogger logger, <span class="built_in">int</span> userId</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过阅读<code>LoggerMessage</code>注解，Source Generator会生成类似上面使用<code>LoggerMessage.Define</code>的代码，从而实现性能优化，同时让开发体验更好。</p><p>使用时，可以直接调用<code>LogUserLoggedIn</code>扩展方法：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UserLoggedIn</span>(<span class="params"><span class="built_in">int</span> userId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 一些业务代码 */</span></span><br><span class="line">  _logger.LogUserLoggedIn(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;日志是一个&lt;strong&gt;切面关注点&lt;/strong&gt;，日志的记录会影响整个系统的性能。在程序的&lt;strong&gt;热点路径&lt;/strong&gt;上，日志记录的开销可能会显著影响应用程序的响应时间和吞吐量，这些日志必须非常轻量、非常高效。&lt;/p&gt;
&lt;p&gt;使用日志消息模板字符串时，为</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET日志" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET日志(3)：Serilog</title>
    <link href="https://blog.xicuodev.top/2025/12/13/dotnet-logging-3-serilog/"/>
    <id>https://blog.xicuodev.top/2025/12/13/dotnet-logging-3-serilog/</id>
    <published>2025-12-13T02:00:00.000Z</published>
    <updated>2026-01-25T11:46:07.082Z</updated>
    
    <content type="html"><![CDATA[<p>无论是作用域、<code>IsEnabled</code>、格式化或消息模板的概念，还是结构化日志记录，<code>Serilog</code>都是这些功能的开创者和标准化者。</p><ul><li>对消息模板、结构化日志、参数解析等都有极佳的支持。</li><li>庞大的Sinks家族：<code>Serilog</code>的<code>Sinks</code>就相当于<code>Logging</code>中的<code>Provider</code>，而<code>Serilog</code>的<code>Sinks</code>可能有几十个甚至上百个。</li></ul><h2 id="创建Serilog日志记录器"><a href="#创建Serilog日志记录器" class="headerlink" title="创建Serilog日志记录器"></a>创建Serilog日志记录器</h2><ul><li>引入<code>Serilog</code>包</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration().CreateLogger();</span><br></pre></td></tr></table></figure></div><h2 id="配置Serilog日志接收器-Sinks"><a href="#配置Serilog日志接收器-Sinks" class="headerlink" title="配置Serilog日志接收器 Sinks"></a>配置Serilog日志接收器 Sinks</h2><ul><li>想要什么接收器，就引入什么<code>Serilog.Sinks.SomeSink</code>包</li><li><code>LoggerConfiguration.WirteTo</code>属性：<code>Sinks</code>扩展该属性以配置它自己，通常是<code>SomeSinks</code>扩展方法</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration()  </span><br><span class="line">    .WriteTo.Console(theme: AnsiConsoleTheme.Code)  </span><br><span class="line">    .CreateLogger();</span><br></pre></td></tr></table></figure></div><ul><li><code>Serilog.Sinks.Console</code>包：<ul><li><code>Console</code>扩展方法：<ul><li><code>theme</code>参数：自定义控制台日志的配色方案</li></ul></li></ul></li><li><code>Serilog.Sinks.File</code>包：<ul><li><code>File</code>扩展方法：<ul><li><code>path</code>参数</li><li><code>rollingInterval</code>参数：滚动间隔，<code>RollingInterval</code>枚举，按多久划分日志文件</li><li><code>rollOnFileSizeLimit</code>参数：文件太大时是否使用新文件</li></ul></li></ul></li></ul><h2 id="静态Serilog日志记录器"><a href="#静态Serilog日志记录器" class="headerlink" title="静态Serilog日志记录器"></a>静态Serilog日志记录器</h2><p>你可以为<code>Log</code>类的<code>Logger</code>属性注册一个日志记录器，它将成为全局可用的静态记录器。</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log.Logger = logger;</span><br></pre></td></tr></table></figure></div><p>当你使用多个提供程序时，其中许多提供程序会在内存中缓冲日志，要把缓存实际刷新到每个提供程序，你可以执行<code>Log.CloseAndFlush()</code>或<code>Log.CloseAndFlushAsync()</code>以提高效率，避免频繁调用。</p><h2 id="将Serilog集成到ASP-NET-Core应用程序"><a href="#将Serilog集成到ASP-NET-Core应用程序" class="headerlink" title="将Serilog集成到ASP.NET Core应用程序"></a>将Serilog集成到ASP.NET Core应用程序</h2><p>将<code>Serilog</code>集成为内置日志记录器的一个提供程序，从而有效“接管”内置日志记录器。</p><ul><li>引入<code>Serilog.AspNetCore</code>包</li><li>在<code>builder.Host</code>属性上调用<code>UseSerilog</code>扩展方法：</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.Host.UseSerilog();</span><br></pre></td></tr></table></figure></div><p>你可以通过设置静态<code>Serilog</code>日志记录器来配置<code>Serilog</code>日志记录器。</p><h2 id="将Serilog集成到非主机应用程序"><a href="#将Serilog集成到非主机应用程序" class="headerlink" title="将Serilog集成到非主机应用程序"></a>将Serilog集成到非主机应用程序</h2><p>例如 Avalonia 桌面应用程序，直接使用 <code>Log.Logger = new LoggerConfiguration()</code> 初始化，在应用启动早期（Avalonia 的 <code>App.OnFrameworkInitializationCompleted</code> 之前或之内）完成配置，应用退出时显式调用 <code>Log.CloseAndFlush()</code>。</p><h2 id="用配置文件配置Serilog"><a href="#用配置文件配置Serilog" class="headerlink" title="用配置文件配置Serilog"></a>用配置文件配置Serilog</h2><p>在 <code>appsettings.json</code> 中配置Serilog：</p><div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Serilog&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;MinimumLevel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Override&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Microsoft.AspNetCore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Warning&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;WriteTo&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Console&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><p>由于已经在配置文件中完成了所有配置，你不需要在代码中硬编码任何配置，只需要导入配置文件：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Log.Logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">.ReadFrom.Configuration(builder.Configuration)</span><br><span class="line">.CreateLogger();</span><br></pre></td></tr></table></figure></div><ul><li><code>builder.Configuration</code>是ASP.NET Core应用程序的配置对象，通常包含<code>appsettings.json</code>文件</li></ul><h2 id="Serilog日志功能增强"><a href="#Serilog日志功能增强" class="headerlink" title="Serilog日志功能增强"></a>Serilog日志功能增强</h2><p><code>Serilog.Enrichers</code>包提供了许多丰富的功能增强，可以为日志事件添加更多上下文信息。</p><ul><li><code>Serilog.Enrichers.Environment</code>包：添加环境信息</li><li><code>Serilog.Enrichers.Thread</code>包：添加线程信息</li><li><code>Serilog.Enrichers.Process</code>包：添加进程信息</li></ul><p>除此之外，你还可以通过<code>Properties</code>属性添加自定义属性。</p><ul><li>这里使用Json格式化器，以便你能够清晰地看到这些增强的属性。</li></ul><div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Serilog&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;MinimumLevel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Override&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Microsoft.AspNetCore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Warning&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;WriteTo&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Console&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;formatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Serilog.Formatting.Json.JsonFormatter, Serilog&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Enrich&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;FromLogContext&quot;</span><span class="punctuation">,</span> <span class="string">&quot;WithMachineName&quot;</span><span class="punctuation">,</span> <span class="string">&quot;WithThreadId&quot;</span><span class="punctuation">,</span> <span class="string">&quot;WithProcessId&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Application&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LoggingDemo&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Environment&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Development&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><ul><li>“<code>FromLogContext</code>“来自日志上下文，”<code>WithMachineName</code>“机器名，”<code>WithThreadId</code>“线程ID，”<code>WithProcessId</code>“进程ID</li></ul><div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;Timestamp&quot;</span><span class="punctuation">:</span><span class="string">&quot;2025-12-15T23:14:09.1705380+08:00&quot;</span><span class="punctuation">,</span><span class="attr">&quot;Level&quot;</span><span class="punctuation">:</span><span class="string">&quot;Information&quot;</span><span class="punctuation">,</span><span class="attr">&quot;MessageTemplate&quot;</span><span class="punctuation">:</span><span class="string">&quot;Now listening on: &#123;address&#125;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;Properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://localhost:5050&quot;</span><span class="punctuation">,</span><span class="attr">&quot;EventId&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span><span class="number">14</span><span class="punctuation">,</span><span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;ListeningOnAddress&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;SourceContext&quot;</span><span class="punctuation">:</span><span class="string">&quot;Microsoft.Hosting.Lifetime&quot;</span><span class="punctuation">,</span><span class="attr">&quot;MachineName&quot;</span><span class="punctuation">:</span><span class="string">&quot;RORMac&quot;</span><span class="punctuation">,</span><span class="attr">&quot;ThreadId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;ProcessId&quot;</span><span class="punctuation">:</span><span class="number">76483</span><span class="punctuation">,</span><span class="attr">&quot;Application&quot;</span><span class="punctuation">:</span><span class="string">&quot;LoggingDemo&quot;</span><span class="punctuation">,</span><span class="attr">&quot;Environment&quot;</span><span class="punctuation">:</span><span class="string">&quot;Development&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><h2 id="用配置文件配置Serilog-Sinks-ApplicationInsights"><a href="#用配置文件配置Serilog-Sinks-ApplicationInsights" class="headerlink" title="用配置文件配置Serilog.Sinks.ApplicationInsights"></a>用配置文件配置<code>Serilog.Sinks.ApplicationInsights</code></h2><div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Serilog&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;MinimumLevel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Override&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Microsoft.AspNetCore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Warning&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;WriteTo&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ApplicationInsights&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;connectionString&quot;</span><span class="punctuation">:</span> <span class="string">&quot;your_connection_string&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;telemetryConverter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Serilog.Sinks.ApplicationInsights.Sinks.ApplicationInsights.TelemetryConverters.TraceTelemetryConverter, Serilog.Sinks.ApplicationInsights&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><p><code>telemetryConverter</code>参数指定了使用<code>TraceTelemetryConverter</code>，将日志作为跟踪数据发送到Application Insights。</p><h2 id="Serilog结构化日志"><a href="#Serilog结构化日志" class="headerlink" title="Serilog结构化日志"></a>Serilog结构化日志</h2><p>在日志消息模板字符串的占位符的开头使用<code>@</code>符号，Serilog可以将对象序列化为结构化数据：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.Information(<span class="string">&quot;User details: &#123;@User&#125;&quot;</span>, user);</span><br></pre></td></tr></table></figure></div><p>对于实现类似JS对象行为的字典<code>Dictionary&lt;string, object&gt;</code>，Serilog能理解这是一个字典，即使不加<code>@</code>符号也会将其展开为序列化结果：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#123; <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Alice&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;Age&quot;</span>, <span class="number">30</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;IsAdmin&quot;</span>, <span class="literal">true</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">logger.Information(<span class="string">&quot;User details: &#123;User&#125;&quot;</span>, dict);</span><br></pre></td></tr></table></figure></div><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[09:18:45 INF] User details: &#123;&quot;Name&quot;: &quot;Alice&quot;, &quot;Age&quot;: 30, &quot;IsAdmin&quot;: true&#125;</span><br></pre></td></tr></table></figure></div><p>如果你希望将字典作为单个对象记录，而不是展开为多个属性，可以使用<code>$</code>符号：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.Information(<span class="string">&quot;User details: &#123;$User&#125;&quot;</span>, dict);</span><br></pre></td></tr></table></figure></div><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[09:20:12 INF] User details: System.Collections.Generic.Dictionary`2[System.String,System.Object]</span><br></pre></td></tr></table></figure></div><p>尽管这是更小众的用法，但你应该知道你有这种能力，且它在某些情况下可能会有用。</p><h2 id="Serilog转换结构化数据"><a href="#Serilog转换结构化数据" class="headerlink" title="Serilog转换结构化数据"></a>Serilog转换结构化数据</h2><p>如果你只想记录某个类型的某些特定字段，可以创建一个自定义转换器：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">.Destructure.ByTransforming&lt;Person&gt;(p =&gt; <span class="keyword">new</span> &#123; p.Name, p.Age &#125;)</span><br><span class="line">.CreateLogger();</span><br></pre></td></tr></table></figure></div><h2 id="Serilog添加自定义属性到日志上下文"><a href="#Serilog添加自定义属性到日志上下文" class="headerlink" title="Serilog添加自定义属性到日志上下文"></a>Serilog添加自定义属性到日志上下文</h2><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (LogContext.PushProperty(<span class="string">&quot;UserId&quot;</span>, userId))</span><br><span class="line">&#123;</span><br><span class="line">logger.Information(<span class="string">&quot;User logged in.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;Timestamp&quot;</span><span class="punctuation">:</span><span class="string">&quot;2025-12-15T23:30:00.1234567+08:00&quot;</span><span class="punctuation">,</span><span class="attr">&quot;Level&quot;</span><span class="punctuation">:</span><span class="string">&quot;Information&quot;</span><span class="punctuation">,</span><span class="attr">&quot;MessageTemplate&quot;</span><span class="punctuation">:</span><span class="string">&quot;User logged in.&quot;</span><span class="punctuation">,</span><span class="attr">&quot;Properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">42</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><h2 id="Serilog记录操作耗时"><a href="#Serilog记录操作耗时" class="headerlink" title="Serilog记录操作耗时"></a>Serilog记录操作耗时</h2><ul><li>引入<code>SerilogTimings</code>包</li><li>使用<code>TimeOperation</code>扩展方法记录操作耗时：</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (logger.TimeOperation(<span class="string">&quot;Processing order &#123;OrderId&#125;&quot;</span>, orderId))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 模拟处理订单的操作</span></span><br><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">500</span>);</span><br><span class="line">logger.Information(<span class="string">&quot;Order &#123;OrderId&#125; processed.&quot;</span>, orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>你还可以控制操作成功或失败时的不同行为：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> operation = logger.TimeOperation(<span class="string">&quot;Processing order &#123;OrderId&#125;&quot;</span>, orderId);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">500</span>);</span><br><span class="line"><span class="comment">/* 这是一段可能会抛出异常的业务代码 */</span></span><br><span class="line"><span class="keyword">if</span> (timeout)</span><br><span class="line">&#123;</span><br><span class="line">operation.Abandon(); <span class="comment">// 标记操作放弃</span></span><br><span class="line">logger.Warning(<span class="string">&quot;Order &#123;OrderId&#125; processing timed out.&quot;</span>, orderId);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">operation.Complete(); <span class="comment">// 标记操作成功</span></span><br><span class="line">logger.Information(<span class="string">&quot;Order &#123;OrderId&#125; processed.&quot;</span>, orderId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">operation.Fail(ex); <span class="comment">// 标记操作失败</span></span><br><span class="line">logger.Error(ex, <span class="string">&quot;Failed to process order &#123;OrderId&#125;.&quot;</span>, orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="Serilog屏蔽敏感数据"><a href="#Serilog屏蔽敏感数据" class="headerlink" title="Serilog屏蔽敏感数据"></a>Serilog屏蔽敏感数据</h2><ul><li>引入<code>Destructurama.Attributed</code>包</li><li>在<code>LoggerConfiguration.Destructure</code>属性上调用<code>UsingAttributes</code>方法：</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">.Destructure.UsingAttributes()</span><br><span class="line">.CreateLogger();</span><br></pre></td></tr></table></figure></div><ul><li>在需要屏蔽的属性上使用<code>[LogMasked]</code>注解：</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">[<span class="meta">LogMasked(Text = <span class="string">&quot;_MASKED_&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Email &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这样在日志中记录<code>User</code>对象时，<code>Email</code>属性将被屏蔽：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[09:45:00 INF] User details: &#123;&quot;Name&quot;: &quot;Alice&quot;, &quot;Email&quot;: &quot;_MASKED_&quot;&#125;</span><br></pre></td></tr></table></figure></div><p>关于<code>LogMasked</code>注解：</p><ul><li><code>Text</code>属性：自定义用于替换敏感数据的文本</li><li><code>ShowFirst</code>属性：显示明文的前几个字符，默认为<code>0</code></li><li><code>ShowLast</code>属性：显示明文的最后几个字符，默认为<code>0</code></li><li><code>PreserveLength</code>属性：是否显示与明文长度匹配的<code>*</code>，默认为<code>false</code></li></ul><p>或者使用<code>[NotLogged]</code>注解，Serilog将完全忽略该属性。</p><h2 id="Serilog异步处理"><a href="#Serilog异步处理" class="headerlink" title="Serilog异步处理"></a>Serilog异步处理</h2><p>Serilog的日志方法都是同步的，但储存日志需要时间，如果日志过多，调用线程将明显阻塞。这意味着，实际的Serilog日志记录器在幕后并不会同步执行工作，而是尽可能<strong>缓冲</strong>，然后<strong>异步地</strong>将日志推送到提供程序，或者说接收器（<code>sink</code>）。如何实现这个机制？</p><p><code>Serilog.Sinks.Async</code>包提供了一个异步接收器，可以异步地将日志写入另一个接收器，从而提高性能。这意味着，它可以为任何接收器提供异步处理能力，即使这些接收器本身是同步的。</p><p>以异步方式注册<code>File</code>接收器，从而提高日志写入文件的性能：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">.WriteTo.Async(x =&gt; x.File(<span class="string">&quot;log.txt&quot;</span>), <span class="number">10</span>)</span><br><span class="line">.CreateLogger();</span><br></pre></td></tr></table></figure></div><p>这时，Serilog会将日志消息放入缓冲区，在缓冲区满时异步地将它们写入文件。这里的<code>10</code>就表示缓冲区的大小为10条日志消息。如果你不指定缓冲区大小，Serilog也会保证日志的周期性写入。</p><p>在应用程序关闭时，调用<code>Log.CloseAndFlush()</code>确保所有缓冲的日志都写入接收器。</p><h2 id="自定义Sink"><a href="#自定义Sink" class="headerlink" title="自定义Sink"></a>自定义Sink</h2><p>实现<code>ILogEventSink</code>接口以自定义<code>Sink</code>，通常会聚合一个可空的<code>IFormatProvider</code>，以便在需要时格式化日志消息。</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyCustomSink</span> : <span class="title">ILogEventSink</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IFormatProvider? _formatProvider;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyCustomSink</span>(<span class="params">IFormatProvider? formatProvider</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">_formatProvider = formatProvider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyCustomSink</span>() : <span class="title">this</span>(<span class="params"><span class="literal">null</span></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Emit</span>(<span class="params">LogEvent logEvent</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 处理日志事件，例如将其写入自定义存储</span></span><br><span class="line"><span class="keyword">var</span> message = logEvent.RenderMessage(_formatProvider);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;log from MyCustomSink: <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><code>RenderMessage</code>方法：使用可选的格式提供程序渲染日志消息</li></ul><p>然后，在<code>LoggerConfiguration.WriteTo</code>属性上调用<code>Sink&lt;TSink&gt;</code>方法（前提是<code>MyCustomSink</code>有无参构造）：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">.WriteTo.Sink&lt;MyCustomSink&gt;()</span><br><span class="line">.CreateLogger();</span><br></pre></td></tr></table></figure></div><p>或者调用<code>Sink(ILogEventSink sink)</code>方法，并使用<code>MyCustomSink</code>的有参构造，更灵活：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">.WriteTo.Sink(<span class="keyword">new</span> MyCustomSink(someFormatProvider))</span><br><span class="line">.CreateLogger();</span><br></pre></td></tr></table></figure></div><p>如果你想跟其他Sinks提供一致的使用体验，可以创建<code>LoggerSinkConfiguration</code>的扩展方法（推荐）：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyCustomSinkExtensions</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoggerConfiguration <span class="title">MyCustomSink</span>(<span class="params"><span class="keyword">this</span> LoggerSinkConfiguration loggerConfiguration,</span></span></span><br><span class="line"><span class="params"><span class="function">IFormatProvider? formatProvider = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> loggerConfiguration.Sink(<span class="keyword">new</span> MyCustomSink(formatProvider));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">.WriteTo.MyCustomSink()</span><br><span class="line">.CreateLogger();</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;无论是作用域、&lt;code&gt;IsEnabled&lt;/code&gt;、格式化或消息模板的概念，还是结构化日志记录，&lt;code&gt;Serilog&lt;/code&gt;都是这些功能的开创者和标准化者。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对消息模板、结构化日志、参数解析等都有极佳的支持。&lt;/li&gt;
&lt;li&gt;</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET日志" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET日志(2)：Microsoft.Extensions.Logging包</title>
    <link href="https://blog.xicuodev.top/2025/12/12/dotnet-logging-2-microsoft-extensions-logging/"/>
    <id>https://blog.xicuodev.top/2025/12/12/dotnet-logging-2-microsoft-extensions-logging/</id>
    <published>2025-12-12T01:49:43.616Z</published>
    <updated>2026-01-25T11:46:11.559Z</updated>
    
    <content type="html"><![CDATA[<p><code>ILogger</code>并不是一个BCL（Basic Class Library，基础类库）接口，而是来自于<code>Microsoft.Extensions.Logging</code>包。如果你是一个类库作者，你可以引用<code>Microsoft.Extensions.Logging.Abstraction</code>抽象依赖，因为开发类库通常用不上这些具体实现。</p><ul><li><code>LoggerFactory</code>日志记录器工厂：<ul><li><code>Create</code>静态方法：创建一个工厂</li><li><code>CreateLogger&lt;&gt;</code>方法：创建一个日志记录器</li></ul></li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LoggerFactory.Create(builder =&gt; &#123; builder.AddConsole(); &#125;);</span><br><span class="line">ILogger logger = loggerFactory.CreateLogger&lt;Program&gt;();</span><br></pre></td></tr></table></figure></div><ul><li><code>ILogger</code>日志记录器：<ul><li><code>Log</code>方法：<code>logLevel</code>, <code>eventId</code>（<a href="#%E6%97%A5%E5%BF%97%E4%BA%8B%E4%BB%B6ID">事件ID</a>）, <code>message</code></li><li><code>LogInformation</code>等扩展方法：封装<code>Log</code>方法，常用</li></ul></li></ul><h2 id="结构化日志记录-语义化日志记录"><a href="#结构化日志记录-语义化日志记录" class="headerlink" title="结构化日志记录&#x2F;语义化日志记录"></a>结构化日志记录&#x2F;语义化日志记录</h2><p>不要使用字符串拼接、模板字符串或格式字符串来传递日志消息，这会导致具体的参数值“烘焙”到日志消息中，从而丢失<code>OriginalFormat</code>（原始格式）。我们希望捕获上下文、作用域、细节和信息，而这正是消息模板字符串和“结构化日志记录”所解决的问题。</p><ul><li><code>Microsoft.Extensions.Logging.Console</code>：<ul><li><code>ILoggingBuilder.AddJsonConsole</code>方法：控制台输出结构化的JSON日志</li></ul></li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> loggerFactory = LoggerFactory.Create(builder =&gt; &#123; builder.AddJsonConsole(); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logger = loggerFactory.CreateLogger&lt;Program&gt;();</span><br><span class="line"></span><br><span class="line">logger.LogInformation(<span class="string">&quot;Hello World! It is &#123;At&#125;.&quot;</span>, DateTime.UtcNow);</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;&quot;EventId&quot;:0,&quot;LogLevel&quot;:&quot;Information&quot;,&quot;Category&quot;:&quot;Program&quot;,&quot;Message&quot;:&quot;Hello World! It is 12/12/2025 02:17:20.&quot;,&quot;State&quot;:&#123;&quot;Message&quot;:&quot;Hello World! It is 12/12/2025 02:17:20.&quot;,&quot;At&quot;:&quot;12/12/2025 02:17:20&quot;,&quot;&#123;OriginalFormat&#125;&quot;:&quot;Hello World! It is &#123;At&#125;.&quot;&#125;&#125;</span></span><br></pre></td></tr></table></figure></div><h2 id="日志类别约定"><a href="#日志类别约定" class="headerlink" title="日志类别约定"></a>日志类别约定</h2><p>日志类别通常约定为注入或使用<code>ILogger&lt;类&gt;</code>的类名。从.NET 6开始，任何自动的依赖注入服务都不会自动注入非泛型的<code>ILogger</code>。</p><h2 id="日志级别约定"><a href="#日志级别约定" class="headerlink" title="日志级别约定"></a>日志级别约定</h2><p>默认情况下，无论是JSON控制台还是普通控制台，它们的最低日志级别都是<code>Information</code>，这意味着它们会完全忽略<code>Debug</code>或<code>Trace</code>级别的日志。</p><ul><li>要设置最低日志级别，使用<code>ILoggingBuilder.SetMinimumLevel</code>方法：</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.SetMinimumLevel(LogLevel.Trace);</span><br></pre></td></tr></table></figure></div><p>在现代应用程序中，尤其是ASP.NET Core中，这类配置通常会集中放在相应的<code>appsettings.json</code>文件中，或你正在使用的其他配置提供程序中。这会自动配置最低日志级别，无需在代码中手动配置。</p><h2 id="日志事件ID"><a href="#日志事件ID" class="headerlink" title="日志事件ID"></a>日志事件ID</h2><p>事件ID用于给一种类型的事件打标签，一个ID代表一种事件。</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.LogInformation(<span class="number">233</span>, <span class="string">&quot;ID为233的事件发生了。&quot;</span>);</span><br></pre></td></tr></table></figure></div><p>非常常见的一种做法是，人们会创建一个事件类，用于集中放置事件ID：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogEvents</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> SomeEvent = <span class="number">233</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>现代结构化日志框架有很多为日志打标签的替代方案，然而事件ID仍是一个非常强大的工具。</p><h2 id="主机应用-Host"><a href="#主机应用-Host" class="headerlink" title="主机应用 Host"></a>主机应用 Host</h2><p>主机通常需要长时间运行，并为客户提供服务，适用于后台工作进程，常见于Web框架。要在非主机控制台应用中使用主机，引入<code>Microsoft.Extensions.Hosting</code>包。</p><p><code>Logging</code>包提供主机<code>IHost</code>的<code>ConfigureLogging</code>扩展方法，接收<code>ILoggingBuilder</code>，从而为主机配置日志服务。</p><h2 id="自定义ILogger日志记录器与Provider日志提供程序"><a href="#自定义ILogger日志记录器与Provider日志提供程序" class="headerlink" title="自定义ILogger日志记录器与Provider日志提供程序"></a>自定义ILogger日志记录器与Provider日志提供程序</h2><p>配置<code>ILogger</code>日志记录器：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.AddJsonConsole().SetMinimumLevel(LogLevel.Trace);</span><br></pre></td></tr></table></figure></div><ul><li><code>ClearProviders</code>方法：清除之前添加的提供程序，从而接着可以换成你想要的</li></ul><p>配置<code>Provider</code>日志提供程序：</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">builder.AddJsonConsole(options =&gt; &#123;  </span><br><span class="line">    options.IncludeScopes = <span class="literal">false</span>;  <span class="comment">//禁用作用域</span></span><br><span class="line">    options.TimestampFormat = <span class="string">&quot;[yyyy-MM-dd HH:mm:ss] &quot;</span>;  </span><br><span class="line">    options.JsonWriterOptions = <span class="keyword">new</span> JsonWriterOptions &#123;  </span><br><span class="line">    Indented = <span class="literal">true</span>  <span class="comment">//以缩进形式输出JSON</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#123;</span></span><br><span class="line"><span class="comment">    &quot;Timestamp&quot;: &quot;[2025-12-12 11:15:07] &quot;,</span></span><br><span class="line"><span class="comment">    &quot;EventId&quot;: 233,</span></span><br><span class="line"><span class="comment">    &quot;LogLevel&quot;: &quot;Information&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Category&quot;: &quot;Program&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Message&quot;: &quot;Hello World! It is 12/12/2025 03:15:07.&quot;,</span></span><br><span class="line"><span class="comment">    &quot;State&quot;: &#123;</span></span><br><span class="line"><span class="comment">        &quot;Message&quot;: &quot;Hello World! It is 12/12/2025 03:15:07.&quot;,</span></span><br><span class="line"><span class="comment">        &quot;At&quot;: &quot;12/12/2025 03:15:07&quot;,</span></span><br><span class="line"><span class="comment">        &quot;&#123;OriginalFormat&#125;&quot;: &quot;Hello World! It is &#123;At&#125;.&quot;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br></pre></td></tr></table></figure></div><h2 id="在appsettings-json中配置日志服务"><a href="#在appsettings-json中配置日志服务" class="headerlink" title="在appsettings.json中配置日志服务"></a>在<code>appsettings.json</code>中配置日志服务</h2><p>你不应该每次为了调整日志配置，都必须修改代码中的日志逻辑，并重新部署应用程序，而是应该将这些配置放在外部的配置文件中。</p><p><code>appsettings.json</code>是大多数类型的应用程序项目模板中的标准配置文件，包括针对特定环境的版本<code>appsettings.Development.json</code>和不区分环境的通用版本<code>appsettings.json</code>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/2025/12/12/dotnet-logging-2-microsoft-extensions-logging/%E5%9C%A8appsettings.json%E4%B8%AD%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1.webp"                                     ></p><h2 id="日志记录异常"><a href="#日志记录异常" class="headerlink" title="日志记录异常"></a>日志记录异常</h2><p>你可以捕获异常，并把它放到Log方法的第一个参数，来记录异常日志。</p><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Something went wrong&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">logger.LogWarning(ex, <span class="string">&quot;Failure during birthday of &#123;Name&#125; who is &#123;Age&#125;&quot;</span>, name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="日志过滤器"><a href="#日志过滤器" class="headerlink" title="日志过滤器"></a>日志过滤器</h2><p>通过<code>LoggingBuilder.AddFilter</code>方法设置日志过滤器，它接收返回布尔值的委托。这个委托可以不传参数，也可以传入提供程序 <code>provider</code>、类别 <code>category</code> 和级别 <code>logLevel</code>。之前设置最低日志级别时，背后就是用到了日志过滤器。</p><ul><li><code>AddFilter&lt;SomeProvider&gt;(类别, 级别)</code>可以针对<code>SomeProvider</code>过滤。</li></ul><p>不过，这种方式更可能在你为他人开发类库时派上用场，而不是在构建微服务这类服务时，因为大多数配置实际上都会放在你的 <code>appsettings.json</code> 中。但知道你拥有灵活性，以备不时之需，总是好的。</p><h2 id="日志提供程序-LoggerProvider"><a href="#日志提供程序-LoggerProvider" class="headerlink" title="日志提供程序 LoggerProvider"></a>日志提供程序 LoggerProvider</h2><p>控制台是临时日志提供程序，一旦停止运行，它和它的日志缓存就不存在了，它们不是持久化的。相反，文件系统就是能够持久存储日志的提供程序。</p><ul><li>ASP.NET Core 显式或隐式内置了 <code>Microsoft.Extensions.Logging</code> 的 <code>Console</code>、<code>Debug</code>、<code>EventLog</code>、<code>EventSource</code> 和 <code>TraceSource</code> 提供程序。</li><li>Microsoft Azure 的云端日志提供程序：<code>ApplicaitonInsights</code>。</li></ul><p>在控制台中配置 <code>ApplicaitonInsights</code> 提供程序：</p><ul><li>引入NuGet包：<ul><li><code>Microsoft.ApplicaitonInsights</code></li><li><code>Microsoft.Extensions.DependencyInjection</code></li><li><code>Microsoft.Extensions.Options.ConfigurationExtensions</code></li><li><code>Microsoft.Extensions.Logging</code></li><li><code>Microsoft.Extensions.Logging.ApplicaitonInsights</code></li></ul></li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> channel = <span class="keyword">new</span> InMemoryChannel();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">IServiceCollection services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.Configure&lt;TelemetryConfiguration&gt;(x =&gt; x.TelemetryChannel = channel);</span><br><span class="line">services.AddLogging(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">x.AddApplicationInsights(</span><br><span class="line">configureTelemetryConfiguration: teleConfig =&gt;</span><br><span class="line">teleConfig.ConnectionString = <span class="string">&quot;your_connection_string&quot;</span>,</span><br><span class="line">configureApplicationInsightsLoggerOptions: _ =&gt; &#123;&#125;</span><br><span class="line">);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> serviceProvider = services.BuildServiceProvider();</span><br><span class="line"><span class="keyword">var</span> logging = serviceProvider.GetRquiredService&lt;ILogger&lt;Program&gt;&gt;();</span><br><span class="line">logging.LogInformation(<span class="string">&quot;Hello from console!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">await</span> channel.FlushAsync(<span class="literal">default</span>);</span><br><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="根据不同的运行环境配置不同的日志提供程序"><a href="#根据不同的运行环境配置不同的日志提供程序" class="headerlink" title="根据不同的运行环境配置不同的日志提供程序"></a>根据不同的运行环境配置不同的日志提供程序</h2><p>在生产环境中，你不希望日志泛滥。你需要对日志行为非常精准地控制，像在生产环境中使用控制台日志记录，可能会拖垮应用程序的性能。在 ASP.NET Core 中，<code>builder.Environment.IsDevelopment</code>方法可以返回当前是否在开发环境。</p><ul><li>这里要获取<code>ILoggingBuilder</code>，使用<code>builder.Logging</code>属性。</li><li>与开发环境（<code>Development</code>）平行的是生产环境（<code>Production</code>）。</li></ul><h2 id="自定义日志提供程序"><a href="#自定义日志提供程序" class="headerlink" title="自定义日志提供程序"></a>自定义日志提供程序</h2><p>要自定义日志提供程序，实现<code>ILogger</code>和<code>ILoggerProvider</code>接口，并在你的<code>LoggerProvider</code>的<code>CreateLogger</code>方法中返回你的<code>Logger</code>。</p><ul><li><code>ILogger</code>接口：<ul><li><code>TState</code>泛型：包含实际日志消息的参数的泛型</li><li><code>BeginScope</code>方法：开启作用域</li><li><code>IsEnabled</code>方法：返回是否启用</li><li><code>Log</code>方法：如果启用，记录日志</li></ul></li></ul><h2 id="日志消息模板字符串"><a href="#日志消息模板字符串" class="headerlink" title="日志消息模板字符串"></a>日志消息模板字符串</h2><ul><li><code>{Total:C}</code>：当前文化的货币格式</li><li><code>{Date:F}</code>：当前文化的日期完整格式</li><li><code>{Date:u}</code>：universal sortable date，通用可排序日期格式</li></ul><p>要实现复杂类型数据的格式化和结构化，你不得不使用<code>JsonSerializer</code>。此时，如果你又要使用<code>JsonConsole</code>，会出现JSON嵌套在JSON中的情况，你必须谨慎处理这里的序列化过程。</p><h2 id="日志作用域-Log-Scope"><a href="#日志作用域-Log-Scope" class="headerlink" title="日志作用域 Log Scope"></a>日志作用域 Log Scope</h2><p>在代码中，存在一段从开始到结束都需要处理特定上下文的区域，这个上下文可能是某种特定的支付、特定的订单、购物车，或者任何在你的业务领域中有意义的内容。尽管一些日志是独立的，但它们所关联的大量数据都与特定的上下文相关。</p><ul><li><code>JsonConsole</code>的<code>Options</code>：<ul><li><code>IncludeScopes</code>属性：是否包含作用域；为<code>true</code>时，结果中将出现<code>Scopes</code>属性，它是一个数组，包含所有上下文数据</li></ul></li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (logging.BeginScope(<span class="string">&quot;&#123;PaymentId&#125;&quot;</span>, paymentId))</span><br><span class="line"><span class="keyword">using</span> (logging.BeginScope(<span class="string">&quot;&#123;TotalAmount:C&#125;&quot;</span>, amount))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">logger.LogInformation(<span class="string">&quot;New payment processing&quot;</span>);</span><br><span class="line"><span class="comment">//processing new payment</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">logger.LogInformation(<span class="string">&quot;Payment processing completed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><code>PaymentId</code>和<code>TotalAmount</code>将作为上下文数据由作用域内的所有日志共享，它们将包含在这些日志的<code>Scopes</code>数组中。</li></ul><h2 id="检查日志是否启用"><a href="#检查日志是否启用" class="headerlink" title="检查日志是否启用"></a>检查日志是否启用</h2><p>虽然日志提供程序通常都会在<code>Log</code>方法的开头检查是否启用，但是为以防万一，你应该在自己的代码中也加入<code>IsEnabled</code>的判断，以确保没有性能问题。</p><h2 id="日志记录操作耗时"><a href="#日志记录操作耗时" class="headerlink" title="日志记录操作耗时"></a>日志记录操作耗时</h2><p>下面是利用<code>Stopwatch</code>类和日志上下文机制记录操作耗时的方法。</p><p><code>Stopwatch</code>类是.NET中测量时间最精确的方案：</p><ul><li><code>GetTimestamp</code>静态方法：获取当前时间戳</li><li><code>GetElapsedTime</code>静态方法：获取传入时间戳到现在的时间间隔</li></ul><p>可以用<code>Stopwatch</code>类结合作用域机制，获取并记录操作耗时。</p><p>创建<code>TimedOperation</code>类，聚合<code>_logger</code>、<code>_logLevel</code>、<code>_eventId</code>、<code>_message</code> 和 <code>_args</code>，实现<code>IDisposable</code>接口：</p><ul><li>在构造方法中获取当前时间戳</li><li>在<code>Dispose</code>方法获取时间间隔，并调用<code>_logger.Log</code>方法记录耗时日志</li></ul><p>创建<code>TimedOperationExtensions</code>类，扩展以支持<code>ILogger</code>接口：</p><ul><li><code>BeginTimedOperation</code>方法：创建并返回<code>TimedOperation</code>对象，用作上下文数据</li><li>创建一个不传入<code>LogLevel</code>的<code>BeginTimedOperation</code>方法重载，并默认使用<code>Information</code>级别</li></ul><div class="code-container" data-rel="Cs"><figure class="iseeu highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (logger.BeginTimedOperation(<span class="string">&quot;Handling new payment&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">logger.LogInformation(<span class="string">&quot;New payment processing&quot;</span>);</span><br><span class="line"><span class="comment">//processing new payment</span></span><br><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="运行时动态修改最低日志级别"><a href="#运行时动态修改最低日志级别" class="headerlink" title="运行时动态修改最低日志级别"></a>运行时动态修改最低日志级别</h2><p>在你的应用程序中，只要支持在运行时热重载或动态重载<code>appsettings.json</code>配置文件，就可以实现运行时动态修改最低日志级别这一功能。而这就是配置提供程序要做的事情了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;&lt;code&gt;ILogger&lt;/code&gt;并不是一个BCL（Basic Class</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET日志" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET日志(1)：概论</title>
    <link href="https://blog.xicuodev.top/2025/12/12/dotnet-logging-1-introduction/"/>
    <id>https://blog.xicuodev.top/2025/12/12/dotnet-logging-1-introduction/</id>
    <published>2025-12-12T01:16:40.993Z</published>
    <updated>2026-01-25T11:46:42.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日志类别-Log-Category"><a href="#日志类别-Log-Category" class="headerlink" title="日志类别 Log Category"></a>日志类别 Log Category</h2><p>日志类别只是一种逻辑方式，用于将不同的日志条目归类到某种统一的分组下。例如，如果你正在运行一个API，微软会将其自身的所有日志归类在<code>Microsoft.Asp.Core</code>这个类别或分组下，你也可以控制自己的日志类别。</p><ul><li><code>ILogger&lt;类&gt;</code>：通常是当前类，如<code>ILogger&lt;Program&gt;</code></li><li><code>LogInformation</code>方法：打印<code>info</code>级别的日志</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info: Program[0]</span><br><span class="line">      Hello World!</span><br></pre></td></tr></table></figure></div><ul><li><code>Program</code>：日志类别</li><li><code>[0]</code>：<a href="/2025/12/12/dotnet-logging-2-microsoft-extensions-logging/#%E6%97%A5%E5%BF%97%E4%BA%8B%E4%BB%B6ID" title=".NET日志(2)：Microsoft.Extensions.Logging包">事件ID</a></li></ul><h2 id="日志级别-Log-Level"><a href="#日志级别-Log-Level" class="headerlink" title="日志级别 Log Level"></a>日志级别 Log Level</h2><p>日记级别代表日志的严重程度：<code>Trace</code>&lt;…&lt;<code>Critical</code>，详见<code>LogLevel</code>枚举。</p><ul><li><code>Trace</code>包含最详细的记录，甚至可以是敏感记录，不能用于生产环境，默认禁用。</li><li><code>Debug</code>用于在开发过程中调试程序，一般不用于生产环境。</li><li><code>Information</code>一般是默认的级别，用于跟踪应用程序的一般流程，可以存储并具有长期价值。</li><li><code>Warning</code>用于突出异常或意外情况，但并不意味着应用程序崩溃、停止或存在根本性错误。</li><li><code>Error</code>表示确实崩溃了，应用程序遇到了无法处理的异常。</li><li><code>Critical</code>表示彻底崩溃，应用程序遇到了不可挽回的致命错误。</li></ul><h2 id="日志提供程序-Log-Provider"><a href="#日志提供程序-Log-Provider" class="headerlink" title="日志提供程序 Log Provider"></a>日志提供程序 Log Provider</h2><p>日志提供程序是日志的输出目标。目标可以是任何东西，它可以是控制台、事件日志、数据库、第三方服务……任何地方。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;日志类别-Log-Category&quot;&gt;&lt;a href=&quot;#日志类别-Log-Category&quot; class=&quot;headerlink&quot; title=&quot;日志类别 Log Category&quot;&gt;&lt;/a&gt;日志类别 Log</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term=".NET日志" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/NET%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>C#常见集合接口</title>
    <link href="https://blog.xicuodev.top/2025/08/26/cs-common-collections-api/"/>
    <id>https://blog.xicuodev.top/2025/08/26/cs-common-collections-api/</id>
    <published>2025-08-26T07:11:00.000Z</published>
    <updated>2026-01-22T13:42:23.653Z</updated>
    
    <content type="html"><![CDATA[<p>下面只列出泛型接口，没有泛型的版本的接口处理数据的逻辑差不多，只是需要装拆箱。</p><ul><li><code>IEnumerable&lt;TItem&gt;</code>：可迭代、可枚举类型<ul><li><code>GetEnumerator</code> 方法：获取迭代器&#x2F;枚举器</li></ul></li><li><code>IEnumerator&lt;TItem&gt;</code>：枚举器，初始不指向任何元素，要调用一次<code>MoveNext</code>方法启动枚举器<ul><li><code>Current</code>属性：当前元素，只<code>get</code></li><li><code>MoveNext</code>方法：启动枚举器，让它指向首个元素（初始）；移动枚举器，让它指向下一个元素（非初始）</li><li><code>Reset</code> 方法：重置枚举器到初始状态</li></ul></li><li><code>ICollection&lt;TItem&gt;</code>：集合<ul><li><code>Add</code> 方法</li><li><code>Remove</code> 方法</li></ul></li><li><code>IList&lt;TItem&gt;</code>：列表<ul><li><code>[int index]</code> 索引器：指定索引的元素，<code>get</code>和<code>set</code></li><li><code>IsFixedSize</code>属性：有无固定大小，只<code>get</code></li><li><code>IsReadOnly</code>属性：是否只读，只<code>get</code></li><li><code>Count</code>属性：元素个数，只<code>get</code></li><li><code>IsSynchronized</code>属性</li><li><code>SyncRoot</code>属性</li><li><code>Add</code>方法</li><li><code>Clear</code>方法</li><li><code>Contains</code>方法</li><li><code>CopyTo</code>方法</li><li><code>GetEnumerator</code>方法</li><li><code>IndexOf</code>方法</li><li><code>Insert</code>方法</li><li><code>Remove</code>方法</li><li><code>RemoveAt</code>方法</li></ul></li><li><code>IDictionary&lt;TKey, TValue&gt;</code>：字典</li></ul><p>来源：<a class="link"   href="https://www.bilibili.com/video/BV13b411b7Ht" >刘铁猛《C#语言入门详解》全集<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;下面只列出泛型接口，没有泛型的版本的接口处理数据的逻辑差不多，只是需要装拆箱。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IEnumerable&amp;lt;TItem&amp;gt;&lt;/code&gt;：可迭代、可枚举类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GetEnumerator&lt;/code&gt;</summary>
        
      
    
    
    
    <category term="编程" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C#技术栈" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term="C#基础" scheme="https://blog.xicuodev.top/categories/%E7%BC%96%E7%A8%8B/C-%E6%8A%80%E6%9C%AF%E6%A0%88/C-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
